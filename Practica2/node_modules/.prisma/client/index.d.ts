
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Follower
 * 
 */
export type Follower = $Result.DefaultSelection<Prisma.$FollowerPayload>
/**
 * Model Comunity
 * 
 */
export type Comunity = $Result.DefaultSelection<Prisma.$ComunityPayload>
/**
 * Model Foro
 * 
 */
export type Foro = $Result.DefaultSelection<Prisma.$ForoPayload>
/**
 * Model Answer
 * 
 */
export type Answer = $Result.DefaultSelection<Prisma.$AnswerPayload>
/**
 * Model Response
 * 
 */
export type Response = $Result.DefaultSelection<Prisma.$ResponsePayload>
/**
 * Model Rol
 * 
 */
export type Rol = $Result.DefaultSelection<Prisma.$RolPayload>
/**
 * Model Link
 * 
 */
export type Link = $Result.DefaultSelection<Prisma.$LinkPayload>
/**
 * Model user_line_link
 * 
 */
export type user_line_link = $Result.DefaultSelection<Prisma.$user_line_linkPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Inv_Line_Pro
 * 
 */
export type Inv_Line_Pro = $Result.DefaultSelection<Prisma.$Inv_Line_ProPayload>
/**
 * Model Publication
 * 
 */
export type Publication = $Result.DefaultSelection<Prisma.$PublicationPayload>
/**
 * Model React
 * 
 */
export type React = $Result.DefaultSelection<Prisma.$ReactPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.follower`: Exposes CRUD operations for the **Follower** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Followers
    * const followers = await prisma.follower.findMany()
    * ```
    */
  get follower(): Prisma.FollowerDelegate<ExtArgs>;

  /**
   * `prisma.comunity`: Exposes CRUD operations for the **Comunity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comunities
    * const comunities = await prisma.comunity.findMany()
    * ```
    */
  get comunity(): Prisma.ComunityDelegate<ExtArgs>;

  /**
   * `prisma.foro`: Exposes CRUD operations for the **Foro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Foros
    * const foros = await prisma.foro.findMany()
    * ```
    */
  get foro(): Prisma.ForoDelegate<ExtArgs>;

  /**
   * `prisma.answer`: Exposes CRUD operations for the **Answer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answer.findMany()
    * ```
    */
  get answer(): Prisma.AnswerDelegate<ExtArgs>;

  /**
   * `prisma.response`: Exposes CRUD operations for the **Response** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Responses
    * const responses = await prisma.response.findMany()
    * ```
    */
  get response(): Prisma.ResponseDelegate<ExtArgs>;

  /**
   * `prisma.rol`: Exposes CRUD operations for the **Rol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rols
    * const rols = await prisma.rol.findMany()
    * ```
    */
  get rol(): Prisma.RolDelegate<ExtArgs>;

  /**
   * `prisma.link`: Exposes CRUD operations for the **Link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Links
    * const links = await prisma.link.findMany()
    * ```
    */
  get link(): Prisma.LinkDelegate<ExtArgs>;

  /**
   * `prisma.user_line_link`: Exposes CRUD operations for the **user_line_link** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_line_links
    * const user_line_links = await prisma.user_line_link.findMany()
    * ```
    */
  get user_line_link(): Prisma.user_line_linkDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.inv_Line_Pro`: Exposes CRUD operations for the **Inv_Line_Pro** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inv_Line_Pros
    * const inv_Line_Pros = await prisma.inv_Line_Pro.findMany()
    * ```
    */
  get inv_Line_Pro(): Prisma.Inv_Line_ProDelegate<ExtArgs>;

  /**
   * `prisma.publication`: Exposes CRUD operations for the **Publication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publication.findMany()
    * ```
    */
  get publication(): Prisma.PublicationDelegate<ExtArgs>;

  /**
   * `prisma.react`: Exposes CRUD operations for the **React** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reacts
    * const reacts = await prisma.react.findMany()
    * ```
    */
  get react(): Prisma.ReactDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.5.2
   * Query Engine version: aebc046ce8b88ebbcb45efe31cbe7d06fd6abc0a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Follower: 'Follower',
    Comunity: 'Comunity',
    Foro: 'Foro',
    Answer: 'Answer',
    Response: 'Response',
    Rol: 'Rol',
    Link: 'Link',
    user_line_link: 'user_line_link',
    Category: 'Category',
    Service: 'Service',
    Product: 'Product',
    Customer: 'Customer',
    Invoice: 'Invoice',
    Inv_Line_Pro: 'Inv_Line_Pro',
    Publication: 'Publication',
    React: 'React',
    Comment: 'Comment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'user' | 'follower' | 'comunity' | 'foro' | 'answer' | 'response' | 'rol' | 'link' | 'user_line_link' | 'category' | 'service' | 'product' | 'customer' | 'invoice' | 'inv_Line_Pro' | 'publication' | 'react' | 'comment'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Follower: {
        payload: Prisma.$FollowerPayload<ExtArgs>
        fields: Prisma.FollowerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          findFirst: {
            args: Prisma.FollowerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          findMany: {
            args: Prisma.FollowerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>[]
          }
          create: {
            args: Prisma.FollowerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          createMany: {
            args: Prisma.FollowerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.FollowerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          update: {
            args: Prisma.FollowerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          deleteMany: {
            args: Prisma.FollowerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.FollowerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.FollowerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$FollowerPayload>
          }
          aggregate: {
            args: Prisma.FollowerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateFollower>
          }
          groupBy: {
            args: Prisma.FollowerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<FollowerGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowerCountArgs<ExtArgs>,
            result: $Utils.Optional<FollowerCountAggregateOutputType> | number
          }
        }
      }
      Comunity: {
        payload: Prisma.$ComunityPayload<ExtArgs>
        fields: Prisma.ComunityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComunityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComunityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          findFirst: {
            args: Prisma.ComunityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComunityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          findMany: {
            args: Prisma.ComunityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>[]
          }
          create: {
            args: Prisma.ComunityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          createMany: {
            args: Prisma.ComunityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ComunityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          update: {
            args: Prisma.ComunityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          deleteMany: {
            args: Prisma.ComunityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ComunityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ComunityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ComunityPayload>
          }
          aggregate: {
            args: Prisma.ComunityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComunity>
          }
          groupBy: {
            args: Prisma.ComunityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ComunityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComunityCountArgs<ExtArgs>,
            result: $Utils.Optional<ComunityCountAggregateOutputType> | number
          }
        }
      }
      Foro: {
        payload: Prisma.$ForoPayload<ExtArgs>
        fields: Prisma.ForoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          findFirst: {
            args: Prisma.ForoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          findMany: {
            args: Prisma.ForoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>[]
          }
          create: {
            args: Prisma.ForoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          createMany: {
            args: Prisma.ForoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ForoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          update: {
            args: Prisma.ForoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          deleteMany: {
            args: Prisma.ForoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ForoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ForoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ForoPayload>
          }
          aggregate: {
            args: Prisma.ForoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateForo>
          }
          groupBy: {
            args: Prisma.ForoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ForoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForoCountArgs<ExtArgs>,
            result: $Utils.Optional<ForoCountAggregateOutputType> | number
          }
        }
      }
      Answer: {
        payload: Prisma.$AnswerPayload<ExtArgs>
        fields: Prisma.AnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnswerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnswerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findFirst: {
            args: Prisma.AnswerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnswerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          findMany: {
            args: Prisma.AnswerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>[]
          }
          create: {
            args: Prisma.AnswerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          createMany: {
            args: Prisma.AnswerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AnswerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          update: {
            args: Prisma.AnswerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          deleteMany: {
            args: Prisma.AnswerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AnswerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AnswerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AnswerPayload>
          }
          aggregate: {
            args: Prisma.AnswerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAnswer>
          }
          groupBy: {
            args: Prisma.AnswerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnswerCountArgs<ExtArgs>,
            result: $Utils.Optional<AnswerCountAggregateOutputType> | number
          }
        }
      }
      Response: {
        payload: Prisma.$ResponsePayload<ExtArgs>
        fields: Prisma.ResponseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ResponseFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ResponseFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findFirst: {
            args: Prisma.ResponseFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ResponseFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          findMany: {
            args: Prisma.ResponseFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>[]
          }
          create: {
            args: Prisma.ResponseCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          createMany: {
            args: Prisma.ResponseCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ResponseDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          update: {
            args: Prisma.ResponseUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          deleteMany: {
            args: Prisma.ResponseDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ResponseUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ResponseUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ResponsePayload>
          }
          aggregate: {
            args: Prisma.ResponseAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateResponse>
          }
          groupBy: {
            args: Prisma.ResponseGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ResponseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ResponseCountArgs<ExtArgs>,
            result: $Utils.Optional<ResponseCountAggregateOutputType> | number
          }
        }
      }
      Rol: {
        payload: Prisma.$RolPayload<ExtArgs>
        fields: Prisma.RolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findFirst: {
            args: Prisma.RolFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          findMany: {
            args: Prisma.RolFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>[]
          }
          create: {
            args: Prisma.RolCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          createMany: {
            args: Prisma.RolCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RolDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          update: {
            args: Prisma.RolUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          deleteMany: {
            args: Prisma.RolDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RolUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RolUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RolPayload>
          }
          aggregate: {
            args: Prisma.RolAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRol>
          }
          groupBy: {
            args: Prisma.RolGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RolGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolCountArgs<ExtArgs>,
            result: $Utils.Optional<RolCountAggregateOutputType> | number
          }
        }
      }
      Link: {
        payload: Prisma.$LinkPayload<ExtArgs>
        fields: Prisma.LinkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          findFirst: {
            args: Prisma.LinkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          findMany: {
            args: Prisma.LinkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>[]
          }
          create: {
            args: Prisma.LinkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          createMany: {
            args: Prisma.LinkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LinkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          update: {
            args: Prisma.LinkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          deleteMany: {
            args: Prisma.LinkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LinkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LinkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$LinkPayload>
          }
          aggregate: {
            args: Prisma.LinkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLink>
          }
          groupBy: {
            args: Prisma.LinkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LinkGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkCountArgs<ExtArgs>,
            result: $Utils.Optional<LinkCountAggregateOutputType> | number
          }
        }
      }
      user_line_link: {
        payload: Prisma.$user_line_linkPayload<ExtArgs>
        fields: Prisma.user_line_linkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_line_linkFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_line_linkFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          findFirst: {
            args: Prisma.user_line_linkFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_line_linkFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          findMany: {
            args: Prisma.user_line_linkFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>[]
          }
          create: {
            args: Prisma.user_line_linkCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          createMany: {
            args: Prisma.user_line_linkCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.user_line_linkDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          update: {
            args: Prisma.user_line_linkUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          deleteMany: {
            args: Prisma.user_line_linkDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.user_line_linkUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.user_line_linkUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$user_line_linkPayload>
          }
          aggregate: {
            args: Prisma.User_line_linkAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser_line_link>
          }
          groupBy: {
            args: Prisma.user_line_linkGroupByArgs<ExtArgs>,
            result: $Utils.Optional<User_line_linkGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_line_linkCountArgs<ExtArgs>,
            result: $Utils.Optional<User_line_linkCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>,
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>,
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>,
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>,
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>,
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Inv_Line_Pro: {
        payload: Prisma.$Inv_Line_ProPayload<ExtArgs>
        fields: Prisma.Inv_Line_ProFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Inv_Line_ProFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Inv_Line_ProFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          findFirst: {
            args: Prisma.Inv_Line_ProFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Inv_Line_ProFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          findMany: {
            args: Prisma.Inv_Line_ProFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>[]
          }
          create: {
            args: Prisma.Inv_Line_ProCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          createMany: {
            args: Prisma.Inv_Line_ProCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Inv_Line_ProDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          update: {
            args: Prisma.Inv_Line_ProUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          deleteMany: {
            args: Prisma.Inv_Line_ProDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Inv_Line_ProUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Inv_Line_ProUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Inv_Line_ProPayload>
          }
          aggregate: {
            args: Prisma.Inv_Line_ProAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateInv_Line_Pro>
          }
          groupBy: {
            args: Prisma.Inv_Line_ProGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Inv_Line_ProGroupByOutputType>[]
          }
          count: {
            args: Prisma.Inv_Line_ProCountArgs<ExtArgs>,
            result: $Utils.Optional<Inv_Line_ProCountAggregateOutputType> | number
          }
        }
      }
      Publication: {
        payload: Prisma.$PublicationPayload<ExtArgs>
        fields: Prisma.PublicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PublicationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PublicationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findFirst: {
            args: Prisma.PublicationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PublicationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          findMany: {
            args: Prisma.PublicationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>[]
          }
          create: {
            args: Prisma.PublicationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          createMany: {
            args: Prisma.PublicationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PublicationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          update: {
            args: Prisma.PublicationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          deleteMany: {
            args: Prisma.PublicationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PublicationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PublicationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$PublicationPayload>
          }
          aggregate: {
            args: Prisma.PublicationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePublication>
          }
          groupBy: {
            args: Prisma.PublicationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PublicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PublicationCountArgs<ExtArgs>,
            result: $Utils.Optional<PublicationCountAggregateOutputType> | number
          }
        }
      }
      React: {
        payload: Prisma.$ReactPayload<ExtArgs>
        fields: Prisma.ReactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          findFirst: {
            args: Prisma.ReactFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          findMany: {
            args: Prisma.ReactFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>[]
          }
          create: {
            args: Prisma.ReactCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          createMany: {
            args: Prisma.ReactCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ReactDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          update: {
            args: Prisma.ReactUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          deleteMany: {
            args: Prisma.ReactDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ReactUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ReactUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ReactPayload>
          }
          aggregate: {
            args: Prisma.ReactAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateReact>
          }
          groupBy: {
            args: Prisma.ReactGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ReactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactCountArgs<ExtArgs>,
            result: $Utils.Optional<ReactCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>,
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    communities: number
    followers: number
    user_line_link: number
    products: number
    publications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communities?: boolean | UserCountOutputTypeCountCommunitiesArgs
    followers?: boolean | UserCountOutputTypeCountFollowersArgs
    user_line_link?: boolean | UserCountOutputTypeCountUser_line_linkArgs
    products?: boolean | UserCountOutputTypeCountProductsArgs
    publications?: boolean | UserCountOutputTypeCountPublicationsArgs
  }

  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommunitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComunityWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowerWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_line_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_line_linkWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }



  /**
   * Count Type ComunityCountOutputType
   */

  export type ComunityCountOutputType = {
    followers: number
    foros: number
  }

  export type ComunityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    followers?: boolean | ComunityCountOutputTypeCountFollowersArgs
    foros?: boolean | ComunityCountOutputTypeCountForosArgs
  }

  // Custom InputTypes

  /**
   * ComunityCountOutputType without action
   */
  export type ComunityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComunityCountOutputType
     */
    select?: ComunityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ComunityCountOutputType without action
   */
  export type ComunityCountOutputTypeCountFollowersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowerWhereInput
  }


  /**
   * ComunityCountOutputType without action
   */
  export type ComunityCountOutputTypeCountForosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForoWhereInput
  }



  /**
   * Count Type AnswerCountOutputType
   */

  export type AnswerCountOutputType = {
    responses: number
  }

  export type AnswerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    responses?: boolean | AnswerCountOutputTypeCountResponsesArgs
  }

  // Custom InputTypes

  /**
   * AnswerCountOutputType without action
   */
  export type AnswerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswerCountOutputType
     */
    select?: AnswerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * AnswerCountOutputType without action
   */
  export type AnswerCountOutputTypeCountResponsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
  }



  /**
   * Count Type RolCountOutputType
   */

  export type RolCountOutputType = {
    links: number
  }

  export type RolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    links?: boolean | RolCountOutputTypeCountLinksArgs
  }

  // Custom InputTypes

  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolCountOutputType
     */
    select?: RolCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RolCountOutputType without action
   */
  export type RolCountOutputTypeCountLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkWhereInput
  }



  /**
   * Count Type LinkCountOutputType
   */

  export type LinkCountOutputType = {
    userLineLink: number
  }

  export type LinkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userLineLink?: boolean | LinkCountOutputTypeCountUserLineLinkArgs
  }

  // Custom InputTypes

  /**
   * LinkCountOutputType without action
   */
  export type LinkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkCountOutputType
     */
    select?: LinkCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * LinkCountOutputType without action
   */
  export type LinkCountOutputTypeCountUserLineLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_line_linkWhereInput
  }



  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    products: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | CategoryCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    products: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | ServiceCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }



  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    inv_line_pros: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inv_line_pros?: boolean | ProductCountOutputTypeCountInv_line_prosArgs
  }

  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountInv_line_prosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inv_Line_ProWhereInput
  }



  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    invices: number
    publications: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invices?: boolean | CustomerCountOutputTypeCountInvicesArgs
    publications?: boolean | CustomerCountOutputTypeCountPublicationsArgs
  }

  // Custom InputTypes

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountInvicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountPublicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
  }



  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    inv_line_pros: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inv_line_pros?: boolean | InvoiceCountOutputTypeCountInv_line_prosArgs
  }

  // Custom InputTypes

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountInv_line_prosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inv_Line_ProWhereInput
  }



  /**
   * Count Type PublicationCountOutputType
   */

  export type PublicationCountOutputType = {
    reactios: number
    comments: number
  }

  export type PublicationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactios?: boolean | PublicationCountOutputTypeCountReactiosArgs
    comments?: boolean | PublicationCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes

  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationCountOutputType
     */
    select?: PublicationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountReactiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactWhereInput
  }


  /**
   * PublicationCountOutputType without action
   */
  export type PublicationCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }



  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    semestre: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    semestre: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    lname: string | null
    phone: string | null
    idCard: string | null
    semestre: number | null
    status: boolean | null
    alias: string | null
    biography: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    lname: string | null
    phone: string | null
    idCard: string | null
    semestre: number | null
    status: boolean | null
    alias: string | null
    biography: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    lname: number
    phone: number
    idCard: number
    semestre: number
    status: number
    alias: number
    biography: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    semestre?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    semestre?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    semestre?: true
    status?: true
    alias?: true
    biography?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    semestre?: true
    status?: true
    alias?: true
    biography?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    semestre?: true
    status?: true
    alias?: true
    biography?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias: string | null
    biography: string
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    lname?: boolean
    phone?: boolean
    idCard?: boolean
    semestre?: boolean
    status?: boolean
    alias?: boolean
    biography?: boolean
    communities?: boolean | User$communitiesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    user_line_link?: boolean | User$user_line_linkArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    publications?: boolean | User$publicationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    lname?: boolean
    phone?: boolean
    idCard?: boolean
    semestre?: boolean
    status?: boolean
    alias?: boolean
    biography?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    communities?: boolean | User$communitiesArgs<ExtArgs>
    followers?: boolean | User$followersArgs<ExtArgs>
    user_line_link?: boolean | User$user_line_linkArgs<ExtArgs>
    products?: boolean | User$productsArgs<ExtArgs>
    publications?: boolean | User$publicationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      communities: Prisma.$ComunityPayload<ExtArgs>[]
      followers: Prisma.$FollowerPayload<ExtArgs>[]
      user_line_link: Prisma.$user_line_linkPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      publications: Prisma.$PublicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string | null
      lname: string
      phone: string
      idCard: string
      semestre: number
      status: boolean
      alias: string | null
      biography: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    communities<T extends User$communitiesArgs<ExtArgs> = {}>(args?: Subset<T, User$communitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findMany'> | Null>;

    followers<T extends User$followersArgs<ExtArgs> = {}>(args?: Subset<T, User$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findMany'> | Null>;

    user_line_link<T extends User$user_line_linkArgs<ExtArgs> = {}>(args?: Subset<T, User$user_line_linkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findMany'> | Null>;

    products<T extends User$productsArgs<ExtArgs> = {}>(args?: Subset<T, User$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    publications<T extends User$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, User$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly lname: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly idCard: FieldRef<"User", 'String'>
    readonly semestre: FieldRef<"User", 'Int'>
    readonly status: FieldRef<"User", 'Boolean'>
    readonly alias: FieldRef<"User", 'String'>
    readonly biography: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes

  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }


  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.communities
   */
  export type User$communitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    where?: ComunityWhereInput
    orderBy?: ComunityOrderByWithRelationInput | ComunityOrderByWithRelationInput[]
    cursor?: ComunityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComunityScalarFieldEnum | ComunityScalarFieldEnum[]
  }


  /**
   * User.followers
   */
  export type User$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    where?: FollowerWhereInput
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    cursor?: FollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowerScalarFieldEnum | FollowerScalarFieldEnum[]
  }


  /**
   * User.user_line_link
   */
  export type User$user_line_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    where?: user_line_linkWhereInput
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    cursor?: user_line_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_line_linkScalarFieldEnum | User_line_linkScalarFieldEnum[]
  }


  /**
   * User.products
   */
  export type User$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * User.publications
   */
  export type User$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }


  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
  }



  /**
   * Model Follower
   */

  export type AggregateFollower = {
    _count: FollowerCountAggregateOutputType | null
    _avg: FollowerAvgAggregateOutputType | null
    _sum: FollowerSumAggregateOutputType | null
    _min: FollowerMinAggregateOutputType | null
    _max: FollowerMaxAggregateOutputType | null
  }

  export type FollowerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    comunityId: number | null
  }

  export type FollowerSumAggregateOutputType = {
    id: number | null
    userId: number | null
    comunityId: number | null
  }

  export type FollowerMinAggregateOutputType = {
    id: number | null
    userId: number | null
    comunityId: number | null
    date: Date | null
    status: boolean | null
  }

  export type FollowerMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    comunityId: number | null
    date: Date | null
    status: boolean | null
  }

  export type FollowerCountAggregateOutputType = {
    id: number
    userId: number
    comunityId: number
    date: number
    status: number
    _all: number
  }


  export type FollowerAvgAggregateInputType = {
    id?: true
    userId?: true
    comunityId?: true
  }

  export type FollowerSumAggregateInputType = {
    id?: true
    userId?: true
    comunityId?: true
  }

  export type FollowerMinAggregateInputType = {
    id?: true
    userId?: true
    comunityId?: true
    date?: true
    status?: true
  }

  export type FollowerMaxAggregateInputType = {
    id?: true
    userId?: true
    comunityId?: true
    date?: true
    status?: true
  }

  export type FollowerCountAggregateInputType = {
    id?: true
    userId?: true
    comunityId?: true
    date?: true
    status?: true
    _all?: true
  }

  export type FollowerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follower to aggregate.
     */
    where?: FollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Followers
    **/
    _count?: true | FollowerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FollowerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FollowerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowerMaxAggregateInputType
  }

  export type GetFollowerAggregateType<T extends FollowerAggregateArgs> = {
        [P in keyof T & keyof AggregateFollower]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollower[P]>
      : GetScalarType<T[P], AggregateFollower[P]>
  }




  export type FollowerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowerWhereInput
    orderBy?: FollowerOrderByWithAggregationInput | FollowerOrderByWithAggregationInput[]
    by: FollowerScalarFieldEnum[] | FollowerScalarFieldEnum
    having?: FollowerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowerCountAggregateInputType | true
    _avg?: FollowerAvgAggregateInputType
    _sum?: FollowerSumAggregateInputType
    _min?: FollowerMinAggregateInputType
    _max?: FollowerMaxAggregateInputType
  }

  export type FollowerGroupByOutputType = {
    id: number
    userId: number
    comunityId: number | null
    date: Date
    status: boolean
    _count: FollowerCountAggregateOutputType | null
    _avg: FollowerAvgAggregateOutputType | null
    _sum: FollowerSumAggregateOutputType | null
    _min: FollowerMinAggregateOutputType | null
    _max: FollowerMaxAggregateOutputType | null
  }

  type GetFollowerGroupByPayload<T extends FollowerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowerGroupByOutputType[P]>
            : GetScalarType<T[P], FollowerGroupByOutputType[P]>
        }
      >
    >


  export type FollowerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    comunityId?: boolean
    date?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | Follower$communityArgs<ExtArgs>
  }, ExtArgs["result"]["follower"]>

  export type FollowerSelectScalar = {
    id?: boolean
    userId?: boolean
    comunityId?: boolean
    date?: boolean
    status?: boolean
  }

  export type FollowerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    community?: boolean | Follower$communityArgs<ExtArgs>
  }


  export type $FollowerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follower"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      community: Prisma.$ComunityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      comunityId: number | null
      date: Date
      status: boolean
    }, ExtArgs["result"]["follower"]>
    composites: {}
  }


  type FollowerGetPayload<S extends boolean | null | undefined | FollowerDefaultArgs> = $Result.GetResult<Prisma.$FollowerPayload, S>

  type FollowerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FollowerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: FollowerCountAggregateInputType | true
    }

  export interface FollowerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follower'], meta: { name: 'Follower' } }
    /**
     * Find zero or one Follower that matches the filter.
     * @param {FollowerFindUniqueArgs} args - Arguments to find a Follower
     * @example
     * // Get one Follower
     * const follower = await prisma.follower.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FollowerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerFindUniqueArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Follower that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {FollowerFindUniqueOrThrowArgs} args - Arguments to find a Follower
     * @example
     * // Get one Follower
     * const follower = await prisma.follower.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends FollowerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Follower that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerFindFirstArgs} args - Arguments to find a Follower
     * @example
     * // Get one Follower
     * const follower = await prisma.follower.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FollowerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerFindFirstArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Follower that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerFindFirstOrThrowArgs} args - Arguments to find a Follower
     * @example
     * // Get one Follower
     * const follower = await prisma.follower.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends FollowerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Followers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Followers
     * const followers = await prisma.follower.findMany()
     * 
     * // Get first 10 Followers
     * const followers = await prisma.follower.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followerWithIdOnly = await prisma.follower.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FollowerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Follower.
     * @param {FollowerCreateArgs} args - Arguments to create a Follower.
     * @example
     * // Create one Follower
     * const Follower = await prisma.follower.create({
     *   data: {
     *     // ... data to create a Follower
     *   }
     * })
     * 
    **/
    create<T extends FollowerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerCreateArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Followers.
     *     @param {FollowerCreateManyArgs} args - Arguments to create many Followers.
     *     @example
     *     // Create many Followers
     *     const follower = await prisma.follower.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FollowerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Follower.
     * @param {FollowerDeleteArgs} args - Arguments to delete one Follower.
     * @example
     * // Delete one Follower
     * const Follower = await prisma.follower.delete({
     *   where: {
     *     // ... filter to delete one Follower
     *   }
     * })
     * 
    **/
    delete<T extends FollowerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerDeleteArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Follower.
     * @param {FollowerUpdateArgs} args - Arguments to update one Follower.
     * @example
     * // Update one Follower
     * const follower = await prisma.follower.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FollowerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerUpdateArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Followers.
     * @param {FollowerDeleteManyArgs} args - Arguments to filter Followers to delete.
     * @example
     * // Delete a few Followers
     * const { count } = await prisma.follower.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FollowerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, FollowerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Followers
     * const follower = await prisma.follower.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FollowerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Follower.
     * @param {FollowerUpsertArgs} args - Arguments to update or create a Follower.
     * @example
     * // Update or create a Follower
     * const follower = await prisma.follower.upsert({
     *   create: {
     *     // ... data to create a Follower
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follower we want to update
     *   }
     * })
    **/
    upsert<T extends FollowerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, FollowerUpsertArgs<ExtArgs>>
    ): Prisma__FollowerClient<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Followers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerCountArgs} args - Arguments to filter Followers to count.
     * @example
     * // Count the number of Followers
     * const count = await prisma.follower.count({
     *   where: {
     *     // ... the filter for the Followers we want to count
     *   }
     * })
    **/
    count<T extends FollowerCountArgs>(
      args?: Subset<T, FollowerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowerAggregateArgs>(args: Subset<T, FollowerAggregateArgs>): Prisma.PrismaPromise<GetFollowerAggregateType<T>>

    /**
     * Group by Follower.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowerGroupByArgs['orderBy'] }
        : { orderBy?: FollowerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follower model
   */
  readonly fields: FollowerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follower.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    community<T extends Follower$communityArgs<ExtArgs> = {}>(args?: Subset<T, Follower$communityArgs<ExtArgs>>): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Follower model
   */ 
  interface FollowerFieldRefs {
    readonly id: FieldRef<"Follower", 'Int'>
    readonly userId: FieldRef<"Follower", 'Int'>
    readonly comunityId: FieldRef<"Follower", 'Int'>
    readonly date: FieldRef<"Follower", 'DateTime'>
    readonly status: FieldRef<"Follower", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Follower findUnique
   */
  export type FollowerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter, which Follower to fetch.
     */
    where: FollowerWhereUniqueInput
  }


  /**
   * Follower findUniqueOrThrow
   */
  export type FollowerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter, which Follower to fetch.
     */
    where: FollowerWhereUniqueInput
  }


  /**
   * Follower findFirst
   */
  export type FollowerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter, which Follower to fetch.
     */
    where?: FollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followers.
     */
    cursor?: FollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followers.
     */
    distinct?: FollowerScalarFieldEnum | FollowerScalarFieldEnum[]
  }


  /**
   * Follower findFirstOrThrow
   */
  export type FollowerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter, which Follower to fetch.
     */
    where?: FollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Followers.
     */
    cursor?: FollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Followers.
     */
    distinct?: FollowerScalarFieldEnum | FollowerScalarFieldEnum[]
  }


  /**
   * Follower findMany
   */
  export type FollowerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter, which Followers to fetch.
     */
    where?: FollowerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Followers to fetch.
     */
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Followers.
     */
    cursor?: FollowerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Followers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Followers.
     */
    skip?: number
    distinct?: FollowerScalarFieldEnum | FollowerScalarFieldEnum[]
  }


  /**
   * Follower create
   */
  export type FollowerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * The data needed to create a Follower.
     */
    data: XOR<FollowerCreateInput, FollowerUncheckedCreateInput>
  }


  /**
   * Follower createMany
   */
  export type FollowerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Followers.
     */
    data: FollowerCreateManyInput | FollowerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Follower update
   */
  export type FollowerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * The data needed to update a Follower.
     */
    data: XOR<FollowerUpdateInput, FollowerUncheckedUpdateInput>
    /**
     * Choose, which Follower to update.
     */
    where: FollowerWhereUniqueInput
  }


  /**
   * Follower updateMany
   */
  export type FollowerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Followers.
     */
    data: XOR<FollowerUpdateManyMutationInput, FollowerUncheckedUpdateManyInput>
    /**
     * Filter which Followers to update
     */
    where?: FollowerWhereInput
  }


  /**
   * Follower upsert
   */
  export type FollowerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * The filter to search for the Follower to update in case it exists.
     */
    where: FollowerWhereUniqueInput
    /**
     * In case the Follower found by the `where` argument doesn't exist, create a new Follower with this data.
     */
    create: XOR<FollowerCreateInput, FollowerUncheckedCreateInput>
    /**
     * In case the Follower was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowerUpdateInput, FollowerUncheckedUpdateInput>
  }


  /**
   * Follower delete
   */
  export type FollowerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    /**
     * Filter which Follower to delete.
     */
    where: FollowerWhereUniqueInput
  }


  /**
   * Follower deleteMany
   */
  export type FollowerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Followers to delete
     */
    where?: FollowerWhereInput
  }


  /**
   * Follower.community
   */
  export type Follower$communityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    where?: ComunityWhereInput
  }


  /**
   * Follower without action
   */
  export type FollowerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
  }



  /**
   * Model Comunity
   */

  export type AggregateComunity = {
    _count: ComunityCountAggregateOutputType | null
    _avg: ComunityAvgAggregateOutputType | null
    _sum: ComunitySumAggregateOutputType | null
    _min: ComunityMinAggregateOutputType | null
    _max: ComunityMaxAggregateOutputType | null
  }

  export type ComunityAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ComunitySumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ComunityMinAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    date_start: Date | null
  }

  export type ComunityMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    name: string | null
    date_start: Date | null
  }

  export type ComunityCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    date_start: number
    _all: number
  }


  export type ComunityAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ComunitySumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ComunityMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date_start?: true
  }

  export type ComunityMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date_start?: true
  }

  export type ComunityCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    date_start?: true
    _all?: true
  }

  export type ComunityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comunity to aggregate.
     */
    where?: ComunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comunities to fetch.
     */
    orderBy?: ComunityOrderByWithRelationInput | ComunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comunities
    **/
    _count?: true | ComunityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComunityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComunitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComunityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComunityMaxAggregateInputType
  }

  export type GetComunityAggregateType<T extends ComunityAggregateArgs> = {
        [P in keyof T & keyof AggregateComunity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComunity[P]>
      : GetScalarType<T[P], AggregateComunity[P]>
  }




  export type ComunityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComunityWhereInput
    orderBy?: ComunityOrderByWithAggregationInput | ComunityOrderByWithAggregationInput[]
    by: ComunityScalarFieldEnum[] | ComunityScalarFieldEnum
    having?: ComunityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComunityCountAggregateInputType | true
    _avg?: ComunityAvgAggregateInputType
    _sum?: ComunitySumAggregateInputType
    _min?: ComunityMinAggregateInputType
    _max?: ComunityMaxAggregateInputType
  }

  export type ComunityGroupByOutputType = {
    id: number
    userId: number
    name: string
    date_start: Date
    _count: ComunityCountAggregateOutputType | null
    _avg: ComunityAvgAggregateOutputType | null
    _sum: ComunitySumAggregateOutputType | null
    _min: ComunityMinAggregateOutputType | null
    _max: ComunityMaxAggregateOutputType | null
  }

  type GetComunityGroupByPayload<T extends ComunityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComunityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComunityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComunityGroupByOutputType[P]>
            : GetScalarType<T[P], ComunityGroupByOutputType[P]>
        }
      >
    >


  export type ComunitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    date_start?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    followers?: boolean | Comunity$followersArgs<ExtArgs>
    foros?: boolean | Comunity$forosArgs<ExtArgs>
    _count?: boolean | ComunityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comunity"]>

  export type ComunitySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    date_start?: boolean
  }

  export type ComunityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    followers?: boolean | Comunity$followersArgs<ExtArgs>
    foros?: boolean | Comunity$forosArgs<ExtArgs>
    _count?: boolean | ComunityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ComunityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comunity"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      followers: Prisma.$FollowerPayload<ExtArgs>[]
      foros: Prisma.$ForoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      name: string
      date_start: Date
    }, ExtArgs["result"]["comunity"]>
    composites: {}
  }


  type ComunityGetPayload<S extends boolean | null | undefined | ComunityDefaultArgs> = $Result.GetResult<Prisma.$ComunityPayload, S>

  type ComunityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComunityFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ComunityCountAggregateInputType | true
    }

  export interface ComunityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comunity'], meta: { name: 'Comunity' } }
    /**
     * Find zero or one Comunity that matches the filter.
     * @param {ComunityFindUniqueArgs} args - Arguments to find a Comunity
     * @example
     * // Get one Comunity
     * const comunity = await prisma.comunity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ComunityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityFindUniqueArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comunity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ComunityFindUniqueOrThrowArgs} args - Arguments to find a Comunity
     * @example
     * // Get one Comunity
     * const comunity = await prisma.comunity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ComunityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comunity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityFindFirstArgs} args - Arguments to find a Comunity
     * @example
     * // Get one Comunity
     * const comunity = await prisma.comunity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ComunityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityFindFirstArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comunity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityFindFirstOrThrowArgs} args - Arguments to find a Comunity
     * @example
     * // Get one Comunity
     * const comunity = await prisma.comunity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ComunityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comunities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comunities
     * const comunities = await prisma.comunity.findMany()
     * 
     * // Get first 10 Comunities
     * const comunities = await prisma.comunity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comunityWithIdOnly = await prisma.comunity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ComunityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comunity.
     * @param {ComunityCreateArgs} args - Arguments to create a Comunity.
     * @example
     * // Create one Comunity
     * const Comunity = await prisma.comunity.create({
     *   data: {
     *     // ... data to create a Comunity
     *   }
     * })
     * 
    **/
    create<T extends ComunityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityCreateArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comunities.
     *     @param {ComunityCreateManyArgs} args - Arguments to create many Comunities.
     *     @example
     *     // Create many Comunities
     *     const comunity = await prisma.comunity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ComunityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comunity.
     * @param {ComunityDeleteArgs} args - Arguments to delete one Comunity.
     * @example
     * // Delete one Comunity
     * const Comunity = await prisma.comunity.delete({
     *   where: {
     *     // ... filter to delete one Comunity
     *   }
     * })
     * 
    **/
    delete<T extends ComunityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityDeleteArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comunity.
     * @param {ComunityUpdateArgs} args - Arguments to update one Comunity.
     * @example
     * // Update one Comunity
     * const comunity = await prisma.comunity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ComunityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityUpdateArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comunities.
     * @param {ComunityDeleteManyArgs} args - Arguments to filter Comunities to delete.
     * @example
     * // Delete a few Comunities
     * const { count } = await prisma.comunity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ComunityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ComunityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comunities
     * const comunity = await prisma.comunity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ComunityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comunity.
     * @param {ComunityUpsertArgs} args - Arguments to update or create a Comunity.
     * @example
     * // Update or create a Comunity
     * const comunity = await prisma.comunity.upsert({
     *   create: {
     *     // ... data to create a Comunity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comunity we want to update
     *   }
     * })
    **/
    upsert<T extends ComunityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ComunityUpsertArgs<ExtArgs>>
    ): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comunities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityCountArgs} args - Arguments to filter Comunities to count.
     * @example
     * // Count the number of Comunities
     * const count = await prisma.comunity.count({
     *   where: {
     *     // ... the filter for the Comunities we want to count
     *   }
     * })
    **/
    count<T extends ComunityCountArgs>(
      args?: Subset<T, ComunityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComunityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComunityAggregateArgs>(args: Subset<T, ComunityAggregateArgs>): Prisma.PrismaPromise<GetComunityAggregateType<T>>

    /**
     * Group by Comunity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComunityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComunityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComunityGroupByArgs['orderBy'] }
        : { orderBy?: ComunityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComunityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComunityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comunity model
   */
  readonly fields: ComunityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comunity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComunityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    followers<T extends Comunity$followersArgs<ExtArgs> = {}>(args?: Subset<T, Comunity$followersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowerPayload<ExtArgs>, T, 'findMany'> | Null>;

    foros<T extends Comunity$forosArgs<ExtArgs> = {}>(args?: Subset<T, Comunity$forosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comunity model
   */ 
  interface ComunityFieldRefs {
    readonly id: FieldRef<"Comunity", 'Int'>
    readonly userId: FieldRef<"Comunity", 'Int'>
    readonly name: FieldRef<"Comunity", 'String'>
    readonly date_start: FieldRef<"Comunity", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Comunity findUnique
   */
  export type ComunityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter, which Comunity to fetch.
     */
    where: ComunityWhereUniqueInput
  }


  /**
   * Comunity findUniqueOrThrow
   */
  export type ComunityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter, which Comunity to fetch.
     */
    where: ComunityWhereUniqueInput
  }


  /**
   * Comunity findFirst
   */
  export type ComunityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter, which Comunity to fetch.
     */
    where?: ComunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comunities to fetch.
     */
    orderBy?: ComunityOrderByWithRelationInput | ComunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comunities.
     */
    cursor?: ComunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comunities.
     */
    distinct?: ComunityScalarFieldEnum | ComunityScalarFieldEnum[]
  }


  /**
   * Comunity findFirstOrThrow
   */
  export type ComunityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter, which Comunity to fetch.
     */
    where?: ComunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comunities to fetch.
     */
    orderBy?: ComunityOrderByWithRelationInput | ComunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comunities.
     */
    cursor?: ComunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comunities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comunities.
     */
    distinct?: ComunityScalarFieldEnum | ComunityScalarFieldEnum[]
  }


  /**
   * Comunity findMany
   */
  export type ComunityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter, which Comunities to fetch.
     */
    where?: ComunityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comunities to fetch.
     */
    orderBy?: ComunityOrderByWithRelationInput | ComunityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comunities.
     */
    cursor?: ComunityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comunities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comunities.
     */
    skip?: number
    distinct?: ComunityScalarFieldEnum | ComunityScalarFieldEnum[]
  }


  /**
   * Comunity create
   */
  export type ComunityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * The data needed to create a Comunity.
     */
    data: XOR<ComunityCreateInput, ComunityUncheckedCreateInput>
  }


  /**
   * Comunity createMany
   */
  export type ComunityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comunities.
     */
    data: ComunityCreateManyInput | ComunityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comunity update
   */
  export type ComunityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * The data needed to update a Comunity.
     */
    data: XOR<ComunityUpdateInput, ComunityUncheckedUpdateInput>
    /**
     * Choose, which Comunity to update.
     */
    where: ComunityWhereUniqueInput
  }


  /**
   * Comunity updateMany
   */
  export type ComunityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comunities.
     */
    data: XOR<ComunityUpdateManyMutationInput, ComunityUncheckedUpdateManyInput>
    /**
     * Filter which Comunities to update
     */
    where?: ComunityWhereInput
  }


  /**
   * Comunity upsert
   */
  export type ComunityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * The filter to search for the Comunity to update in case it exists.
     */
    where: ComunityWhereUniqueInput
    /**
     * In case the Comunity found by the `where` argument doesn't exist, create a new Comunity with this data.
     */
    create: XOR<ComunityCreateInput, ComunityUncheckedCreateInput>
    /**
     * In case the Comunity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComunityUpdateInput, ComunityUncheckedUpdateInput>
  }


  /**
   * Comunity delete
   */
  export type ComunityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
    /**
     * Filter which Comunity to delete.
     */
    where: ComunityWhereUniqueInput
  }


  /**
   * Comunity deleteMany
   */
  export type ComunityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comunities to delete
     */
    where?: ComunityWhereInput
  }


  /**
   * Comunity.followers
   */
  export type Comunity$followersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follower
     */
    select?: FollowerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: FollowerInclude<ExtArgs> | null
    where?: FollowerWhereInput
    orderBy?: FollowerOrderByWithRelationInput | FollowerOrderByWithRelationInput[]
    cursor?: FollowerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowerScalarFieldEnum | FollowerScalarFieldEnum[]
  }


  /**
   * Comunity.foros
   */
  export type Comunity$forosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    where?: ForoWhereInput
    orderBy?: ForoOrderByWithRelationInput | ForoOrderByWithRelationInput[]
    cursor?: ForoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForoScalarFieldEnum | ForoScalarFieldEnum[]
  }


  /**
   * Comunity without action
   */
  export type ComunityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comunity
     */
    select?: ComunitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ComunityInclude<ExtArgs> | null
  }



  /**
   * Model Foro
   */

  export type AggregateForo = {
    _count: ForoCountAggregateOutputType | null
    _avg: ForoAvgAggregateOutputType | null
    _sum: ForoSumAggregateOutputType | null
    _min: ForoMinAggregateOutputType | null
    _max: ForoMaxAggregateOutputType | null
  }

  export type ForoAvgAggregateOutputType = {
    id: number | null
    comunityId: number | null
  }

  export type ForoSumAggregateOutputType = {
    id: number | null
    comunityId: number | null
  }

  export type ForoMinAggregateOutputType = {
    id: number | null
    subject: string | null
    description: string | null
    date_publication: Date | null
    date_update: Date | null
    comunityId: number | null
  }

  export type ForoMaxAggregateOutputType = {
    id: number | null
    subject: string | null
    description: string | null
    date_publication: Date | null
    date_update: Date | null
    comunityId: number | null
  }

  export type ForoCountAggregateOutputType = {
    id: number
    subject: number
    description: number
    date_publication: number
    date_update: number
    comunityId: number
    _all: number
  }


  export type ForoAvgAggregateInputType = {
    id?: true
    comunityId?: true
  }

  export type ForoSumAggregateInputType = {
    id?: true
    comunityId?: true
  }

  export type ForoMinAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    date_publication?: true
    date_update?: true
    comunityId?: true
  }

  export type ForoMaxAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    date_publication?: true
    date_update?: true
    comunityId?: true
  }

  export type ForoCountAggregateInputType = {
    id?: true
    subject?: true
    description?: true
    date_publication?: true
    date_update?: true
    comunityId?: true
    _all?: true
  }

  export type ForoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foro to aggregate.
     */
    where?: ForoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foros to fetch.
     */
    orderBy?: ForoOrderByWithRelationInput | ForoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Foros
    **/
    _count?: true | ForoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForoMaxAggregateInputType
  }

  export type GetForoAggregateType<T extends ForoAggregateArgs> = {
        [P in keyof T & keyof AggregateForo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForo[P]>
      : GetScalarType<T[P], AggregateForo[P]>
  }




  export type ForoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForoWhereInput
    orderBy?: ForoOrderByWithAggregationInput | ForoOrderByWithAggregationInput[]
    by: ForoScalarFieldEnum[] | ForoScalarFieldEnum
    having?: ForoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForoCountAggregateInputType | true
    _avg?: ForoAvgAggregateInputType
    _sum?: ForoSumAggregateInputType
    _min?: ForoMinAggregateInputType
    _max?: ForoMaxAggregateInputType
  }

  export type ForoGroupByOutputType = {
    id: number
    subject: string | null
    description: string
    date_publication: Date | null
    date_update: Date | null
    comunityId: number
    _count: ForoCountAggregateOutputType | null
    _avg: ForoAvgAggregateOutputType | null
    _sum: ForoSumAggregateOutputType | null
    _min: ForoMinAggregateOutputType | null
    _max: ForoMaxAggregateOutputType | null
  }

  type GetForoGroupByPayload<T extends ForoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForoGroupByOutputType[P]>
            : GetScalarType<T[P], ForoGroupByOutputType[P]>
        }
      >
    >


  export type ForoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subject?: boolean
    description?: boolean
    date_publication?: boolean
    date_update?: boolean
    comunityId?: boolean
    answers?: boolean | Foro$answersArgs<ExtArgs>
    responses?: boolean | Foro$responsesArgs<ExtArgs>
    comunity?: boolean | ComunityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["foro"]>

  export type ForoSelectScalar = {
    id?: boolean
    subject?: boolean
    description?: boolean
    date_publication?: boolean
    date_update?: boolean
    comunityId?: boolean
  }

  export type ForoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | Foro$answersArgs<ExtArgs>
    responses?: boolean | Foro$responsesArgs<ExtArgs>
    comunity?: boolean | ComunityDefaultArgs<ExtArgs>
  }


  export type $ForoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Foro"
    objects: {
      answers: Prisma.$AnswerPayload<ExtArgs> | null
      responses: Prisma.$ResponsePayload<ExtArgs> | null
      comunity: Prisma.$ComunityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      subject: string | null
      description: string
      date_publication: Date | null
      date_update: Date | null
      comunityId: number
    }, ExtArgs["result"]["foro"]>
    composites: {}
  }


  type ForoGetPayload<S extends boolean | null | undefined | ForoDefaultArgs> = $Result.GetResult<Prisma.$ForoPayload, S>

  type ForoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForoFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ForoCountAggregateInputType | true
    }

  export interface ForoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Foro'], meta: { name: 'Foro' } }
    /**
     * Find zero or one Foro that matches the filter.
     * @param {ForoFindUniqueArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ForoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ForoFindUniqueArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Foro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ForoFindUniqueOrThrowArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ForoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Foro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoFindFirstArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ForoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoFindFirstArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Foro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoFindFirstOrThrowArgs} args - Arguments to find a Foro
     * @example
     * // Get one Foro
     * const foro = await prisma.foro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ForoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Foros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Foros
     * const foros = await prisma.foro.findMany()
     * 
     * // Get first 10 Foros
     * const foros = await prisma.foro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const foroWithIdOnly = await prisma.foro.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ForoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Foro.
     * @param {ForoCreateArgs} args - Arguments to create a Foro.
     * @example
     * // Create one Foro
     * const Foro = await prisma.foro.create({
     *   data: {
     *     // ... data to create a Foro
     *   }
     * })
     * 
    **/
    create<T extends ForoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ForoCreateArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Foros.
     *     @param {ForoCreateManyArgs} args - Arguments to create many Foros.
     *     @example
     *     // Create many Foros
     *     const foro = await prisma.foro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ForoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Foro.
     * @param {ForoDeleteArgs} args - Arguments to delete one Foro.
     * @example
     * // Delete one Foro
     * const Foro = await prisma.foro.delete({
     *   where: {
     *     // ... filter to delete one Foro
     *   }
     * })
     * 
    **/
    delete<T extends ForoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ForoDeleteArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Foro.
     * @param {ForoUpdateArgs} args - Arguments to update one Foro.
     * @example
     * // Update one Foro
     * const foro = await prisma.foro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ForoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ForoUpdateArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Foros.
     * @param {ForoDeleteManyArgs} args - Arguments to filter Foros to delete.
     * @example
     * // Delete a few Foros
     * const { count } = await prisma.foro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ForoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ForoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Foros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Foros
     * const foro = await prisma.foro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ForoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ForoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Foro.
     * @param {ForoUpsertArgs} args - Arguments to update or create a Foro.
     * @example
     * // Update or create a Foro
     * const foro = await prisma.foro.upsert({
     *   create: {
     *     // ... data to create a Foro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Foro we want to update
     *   }
     * })
    **/
    upsert<T extends ForoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ForoUpsertArgs<ExtArgs>>
    ): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Foros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoCountArgs} args - Arguments to filter Foros to count.
     * @example
     * // Count the number of Foros
     * const count = await prisma.foro.count({
     *   where: {
     *     // ... the filter for the Foros we want to count
     *   }
     * })
    **/
    count<T extends ForoCountArgs>(
      args?: Subset<T, ForoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Foro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForoAggregateArgs>(args: Subset<T, ForoAggregateArgs>): Prisma.PrismaPromise<GetForoAggregateType<T>>

    /**
     * Group by Foro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForoGroupByArgs['orderBy'] }
        : { orderBy?: ForoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Foro model
   */
  readonly fields: ForoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Foro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    answers<T extends Foro$answersArgs<ExtArgs> = {}>(args?: Subset<T, Foro$answersArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    responses<T extends Foro$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Foro$responsesArgs<ExtArgs>>): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    comunity<T extends ComunityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ComunityDefaultArgs<ExtArgs>>): Prisma__ComunityClient<$Result.GetResult<Prisma.$ComunityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Foro model
   */ 
  interface ForoFieldRefs {
    readonly id: FieldRef<"Foro", 'Int'>
    readonly subject: FieldRef<"Foro", 'String'>
    readonly description: FieldRef<"Foro", 'String'>
    readonly date_publication: FieldRef<"Foro", 'DateTime'>
    readonly date_update: FieldRef<"Foro", 'DateTime'>
    readonly comunityId: FieldRef<"Foro", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Foro findUnique
   */
  export type ForoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter, which Foro to fetch.
     */
    where: ForoWhereUniqueInput
  }


  /**
   * Foro findUniqueOrThrow
   */
  export type ForoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter, which Foro to fetch.
     */
    where: ForoWhereUniqueInput
  }


  /**
   * Foro findFirst
   */
  export type ForoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter, which Foro to fetch.
     */
    where?: ForoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foros to fetch.
     */
    orderBy?: ForoOrderByWithRelationInput | ForoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foros.
     */
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foros.
     */
    distinct?: ForoScalarFieldEnum | ForoScalarFieldEnum[]
  }


  /**
   * Foro findFirstOrThrow
   */
  export type ForoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter, which Foro to fetch.
     */
    where?: ForoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foros to fetch.
     */
    orderBy?: ForoOrderByWithRelationInput | ForoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Foros.
     */
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Foros.
     */
    distinct?: ForoScalarFieldEnum | ForoScalarFieldEnum[]
  }


  /**
   * Foro findMany
   */
  export type ForoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter, which Foros to fetch.
     */
    where?: ForoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Foros to fetch.
     */
    orderBy?: ForoOrderByWithRelationInput | ForoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Foros.
     */
    cursor?: ForoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Foros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Foros.
     */
    skip?: number
    distinct?: ForoScalarFieldEnum | ForoScalarFieldEnum[]
  }


  /**
   * Foro create
   */
  export type ForoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * The data needed to create a Foro.
     */
    data: XOR<ForoCreateInput, ForoUncheckedCreateInput>
  }


  /**
   * Foro createMany
   */
  export type ForoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Foros.
     */
    data: ForoCreateManyInput | ForoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Foro update
   */
  export type ForoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * The data needed to update a Foro.
     */
    data: XOR<ForoUpdateInput, ForoUncheckedUpdateInput>
    /**
     * Choose, which Foro to update.
     */
    where: ForoWhereUniqueInput
  }


  /**
   * Foro updateMany
   */
  export type ForoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Foros.
     */
    data: XOR<ForoUpdateManyMutationInput, ForoUncheckedUpdateManyInput>
    /**
     * Filter which Foros to update
     */
    where?: ForoWhereInput
  }


  /**
   * Foro upsert
   */
  export type ForoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * The filter to search for the Foro to update in case it exists.
     */
    where: ForoWhereUniqueInput
    /**
     * In case the Foro found by the `where` argument doesn't exist, create a new Foro with this data.
     */
    create: XOR<ForoCreateInput, ForoUncheckedCreateInput>
    /**
     * In case the Foro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForoUpdateInput, ForoUncheckedUpdateInput>
  }


  /**
   * Foro delete
   */
  export type ForoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
    /**
     * Filter which Foro to delete.
     */
    where: ForoWhereUniqueInput
  }


  /**
   * Foro deleteMany
   */
  export type ForoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Foros to delete
     */
    where?: ForoWhereInput
  }


  /**
   * Foro.answers
   */
  export type Foro$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    where?: AnswerWhereInput
  }


  /**
   * Foro.responses
   */
  export type Foro$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
  }


  /**
   * Foro without action
   */
  export type ForoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Foro
     */
    select?: ForoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ForoInclude<ExtArgs> | null
  }



  /**
   * Model Answer
   */

  export type AggregateAnswer = {
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  export type AnswerAvgAggregateOutputType = {
    id: number | null
    foroId: number | null
  }

  export type AnswerSumAggregateOutputType = {
    id: number | null
    foroId: number | null
  }

  export type AnswerMinAggregateOutputType = {
    id: number | null
    message: string | null
    foroId: number | null
  }

  export type AnswerMaxAggregateOutputType = {
    id: number | null
    message: string | null
    foroId: number | null
  }

  export type AnswerCountAggregateOutputType = {
    id: number
    message: number
    foroId: number
    _all: number
  }


  export type AnswerAvgAggregateInputType = {
    id?: true
    foroId?: true
  }

  export type AnswerSumAggregateInputType = {
    id?: true
    foroId?: true
  }

  export type AnswerMinAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
  }

  export type AnswerMaxAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
  }

  export type AnswerCountAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
    _all?: true
  }

  export type AnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answer to aggregate.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Answers
    **/
    _count?: true | AnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswerMaxAggregateInputType
  }

  export type GetAnswerAggregateType<T extends AnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswer[P]>
      : GetScalarType<T[P], AggregateAnswer[P]>
  }




  export type AnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnswerWhereInput
    orderBy?: AnswerOrderByWithAggregationInput | AnswerOrderByWithAggregationInput[]
    by: AnswerScalarFieldEnum[] | AnswerScalarFieldEnum
    having?: AnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswerCountAggregateInputType | true
    _avg?: AnswerAvgAggregateInputType
    _sum?: AnswerSumAggregateInputType
    _min?: AnswerMinAggregateInputType
    _max?: AnswerMaxAggregateInputType
  }

  export type AnswerGroupByOutputType = {
    id: number
    message: string | null
    foroId: number
    _count: AnswerCountAggregateOutputType | null
    _avg: AnswerAvgAggregateOutputType | null
    _sum: AnswerSumAggregateOutputType | null
    _min: AnswerMinAggregateOutputType | null
    _max: AnswerMaxAggregateOutputType | null
  }

  type GetAnswerGroupByPayload<T extends AnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswerGroupByOutputType[P]>
            : GetScalarType<T[P], AnswerGroupByOutputType[P]>
        }
      >
    >


  export type AnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    foroId?: boolean
    foro?: boolean | ForoDefaultArgs<ExtArgs>
    responses?: boolean | Answer$responsesArgs<ExtArgs>
    _count?: boolean | AnswerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answer"]>

  export type AnswerSelectScalar = {
    id?: boolean
    message?: boolean
    foroId?: boolean
  }

  export type AnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foro?: boolean | ForoDefaultArgs<ExtArgs>
    responses?: boolean | Answer$responsesArgs<ExtArgs>
    _count?: boolean | AnswerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $AnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Answer"
    objects: {
      foro: Prisma.$ForoPayload<ExtArgs>
      responses: Prisma.$ResponsePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string | null
      foroId: number
    }, ExtArgs["result"]["answer"]>
    composites: {}
  }


  type AnswerGetPayload<S extends boolean | null | undefined | AnswerDefaultArgs> = $Result.GetResult<Prisma.$AnswerPayload, S>

  type AnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnswerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: AnswerCountAggregateInputType | true
    }

  export interface AnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Answer'], meta: { name: 'Answer' } }
    /**
     * Find zero or one Answer that matches the filter.
     * @param {AnswerFindUniqueArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AnswerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerFindUniqueArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Answer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {AnswerFindUniqueOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AnswerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Answer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AnswerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerFindFirstArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Answer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindFirstOrThrowArgs} args - Arguments to find a Answer
     * @example
     * // Get one Answer
     * const answer = await prisma.answer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AnswerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answer.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answerWithIdOnly = await prisma.answer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AnswerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Answer.
     * @param {AnswerCreateArgs} args - Arguments to create a Answer.
     * @example
     * // Create one Answer
     * const Answer = await prisma.answer.create({
     *   data: {
     *     // ... data to create a Answer
     *   }
     * })
     * 
    **/
    create<T extends AnswerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerCreateArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Answers.
     *     @param {AnswerCreateManyArgs} args - Arguments to create many Answers.
     *     @example
     *     // Create many Answers
     *     const answer = await prisma.answer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends AnswerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Answer.
     * @param {AnswerDeleteArgs} args - Arguments to delete one Answer.
     * @example
     * // Delete one Answer
     * const Answer = await prisma.answer.delete({
     *   where: {
     *     // ... filter to delete one Answer
     *   }
     * })
     * 
    **/
    delete<T extends AnswerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerDeleteArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Answer.
     * @param {AnswerUpdateArgs} args - Arguments to update one Answer.
     * @example
     * // Update one Answer
     * const answer = await prisma.answer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AnswerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerUpdateArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Answers.
     * @param {AnswerDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AnswerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AnswerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answer = await prisma.answer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AnswerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Answer.
     * @param {AnswerUpsertArgs} args - Arguments to update or create a Answer.
     * @example
     * // Update or create a Answer
     * const answer = await prisma.answer.upsert({
     *   create: {
     *     // ... data to create a Answer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answer we want to update
     *   }
     * })
    **/
    upsert<T extends AnswerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AnswerUpsertArgs<ExtArgs>>
    ): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answer.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends AnswerCountArgs>(
      args?: Subset<T, AnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswerAggregateArgs>(args: Subset<T, AnswerAggregateArgs>): Prisma.PrismaPromise<GetAnswerAggregateType<T>>

    /**
     * Group by Answer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnswerGroupByArgs['orderBy'] }
        : { orderBy?: AnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Answer model
   */
  readonly fields: AnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Answer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    foro<T extends ForoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForoDefaultArgs<ExtArgs>>): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    responses<T extends Answer$responsesArgs<ExtArgs> = {}>(args?: Subset<T, Answer$responsesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Answer model
   */ 
  interface AnswerFieldRefs {
    readonly id: FieldRef<"Answer", 'Int'>
    readonly message: FieldRef<"Answer", 'String'>
    readonly foroId: FieldRef<"Answer", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Answer findUnique
   */
  export type AnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer findUniqueOrThrow
   */
  export type AnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer findFirst
   */
  export type AnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }


  /**
   * Answer findFirstOrThrow
   */
  export type AnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answer to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Answers.
     */
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }


  /**
   * Answer findMany
   */
  export type AnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter, which Answers to fetch.
     */
    where?: AnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Answers to fetch.
     */
    orderBy?: AnswerOrderByWithRelationInput | AnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Answers.
     */
    cursor?: AnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Answers.
     */
    skip?: number
    distinct?: AnswerScalarFieldEnum | AnswerScalarFieldEnum[]
  }


  /**
   * Answer create
   */
  export type AnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a Answer.
     */
    data: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
  }


  /**
   * Answer createMany
   */
  export type AnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Answers.
     */
    data: AnswerCreateManyInput | AnswerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Answer update
   */
  export type AnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a Answer.
     */
    data: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
    /**
     * Choose, which Answer to update.
     */
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer updateMany
   */
  export type AnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Answers.
     */
    data: XOR<AnswerUpdateManyMutationInput, AnswerUncheckedUpdateManyInput>
    /**
     * Filter which Answers to update
     */
    where?: AnswerWhereInput
  }


  /**
   * Answer upsert
   */
  export type AnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the Answer to update in case it exists.
     */
    where: AnswerWhereUniqueInput
    /**
     * In case the Answer found by the `where` argument doesn't exist, create a new Answer with this data.
     */
    create: XOR<AnswerCreateInput, AnswerUncheckedCreateInput>
    /**
     * In case the Answer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnswerUpdateInput, AnswerUncheckedUpdateInput>
  }


  /**
   * Answer delete
   */
  export type AnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
    /**
     * Filter which Answer to delete.
     */
    where: AnswerWhereUniqueInput
  }


  /**
   * Answer deleteMany
   */
  export type AnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Answers to delete
     */
    where?: AnswerWhereInput
  }


  /**
   * Answer.responses
   */
  export type Answer$responsesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    cursor?: ResponseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }


  /**
   * Answer without action
   */
  export type AnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Answer
     */
    select?: AnswerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: AnswerInclude<ExtArgs> | null
  }



  /**
   * Model Response
   */

  export type AggregateResponse = {
    _count: ResponseCountAggregateOutputType | null
    _avg: ResponseAvgAggregateOutputType | null
    _sum: ResponseSumAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  export type ResponseAvgAggregateOutputType = {
    id: number | null
    foroId: number | null
    answerId: number | null
  }

  export type ResponseSumAggregateOutputType = {
    id: number | null
    foroId: number | null
    answerId: number | null
  }

  export type ResponseMinAggregateOutputType = {
    id: number | null
    message: string | null
    foroId: number | null
    answerId: number | null
  }

  export type ResponseMaxAggregateOutputType = {
    id: number | null
    message: string | null
    foroId: number | null
    answerId: number | null
  }

  export type ResponseCountAggregateOutputType = {
    id: number
    message: number
    foroId: number
    answerId: number
    _all: number
  }


  export type ResponseAvgAggregateInputType = {
    id?: true
    foroId?: true
    answerId?: true
  }

  export type ResponseSumAggregateInputType = {
    id?: true
    foroId?: true
    answerId?: true
  }

  export type ResponseMinAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
    answerId?: true
  }

  export type ResponseMaxAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
    answerId?: true
  }

  export type ResponseCountAggregateInputType = {
    id?: true
    message?: true
    foroId?: true
    answerId?: true
    _all?: true
  }

  export type ResponseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Response to aggregate.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Responses
    **/
    _count?: true | ResponseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResponseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResponseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResponseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResponseMaxAggregateInputType
  }

  export type GetResponseAggregateType<T extends ResponseAggregateArgs> = {
        [P in keyof T & keyof AggregateResponse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResponse[P]>
      : GetScalarType<T[P], AggregateResponse[P]>
  }




  export type ResponseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ResponseWhereInput
    orderBy?: ResponseOrderByWithAggregationInput | ResponseOrderByWithAggregationInput[]
    by: ResponseScalarFieldEnum[] | ResponseScalarFieldEnum
    having?: ResponseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResponseCountAggregateInputType | true
    _avg?: ResponseAvgAggregateInputType
    _sum?: ResponseSumAggregateInputType
    _min?: ResponseMinAggregateInputType
    _max?: ResponseMaxAggregateInputType
  }

  export type ResponseGroupByOutputType = {
    id: number
    message: string | null
    foroId: number
    answerId: number
    _count: ResponseCountAggregateOutputType | null
    _avg: ResponseAvgAggregateOutputType | null
    _sum: ResponseSumAggregateOutputType | null
    _min: ResponseMinAggregateOutputType | null
    _max: ResponseMaxAggregateOutputType | null
  }

  type GetResponseGroupByPayload<T extends ResponseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ResponseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResponseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResponseGroupByOutputType[P]>
            : GetScalarType<T[P], ResponseGroupByOutputType[P]>
        }
      >
    >


  export type ResponseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    foroId?: boolean
    answerId?: boolean
    foro?: boolean | ForoDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["response"]>

  export type ResponseSelectScalar = {
    id?: boolean
    message?: boolean
    foroId?: boolean
    answerId?: boolean
  }

  export type ResponseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    foro?: boolean | ForoDefaultArgs<ExtArgs>
    answer?: boolean | AnswerDefaultArgs<ExtArgs>
  }


  export type $ResponsePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Response"
    objects: {
      foro: Prisma.$ForoPayload<ExtArgs>
      answer: Prisma.$AnswerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message: string | null
      foroId: number
      answerId: number
    }, ExtArgs["result"]["response"]>
    composites: {}
  }


  type ResponseGetPayload<S extends boolean | null | undefined | ResponseDefaultArgs> = $Result.GetResult<Prisma.$ResponsePayload, S>

  type ResponseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ResponseFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ResponseCountAggregateInputType | true
    }

  export interface ResponseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Response'], meta: { name: 'Response' } }
    /**
     * Find zero or one Response that matches the filter.
     * @param {ResponseFindUniqueArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResponseFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseFindUniqueArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Response that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ResponseFindUniqueOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ResponseFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Response that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResponseFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseFindFirstArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Response that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindFirstOrThrowArgs} args - Arguments to find a Response
     * @example
     * // Get one Response
     * const response = await prisma.response.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ResponseFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Responses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Responses
     * const responses = await prisma.response.findMany()
     * 
     * // Get first 10 Responses
     * const responses = await prisma.response.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const responseWithIdOnly = await prisma.response.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResponseFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Response.
     * @param {ResponseCreateArgs} args - Arguments to create a Response.
     * @example
     * // Create one Response
     * const Response = await prisma.response.create({
     *   data: {
     *     // ... data to create a Response
     *   }
     * })
     * 
    **/
    create<T extends ResponseCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseCreateArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Responses.
     *     @param {ResponseCreateManyArgs} args - Arguments to create many Responses.
     *     @example
     *     // Create many Responses
     *     const response = await prisma.response.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResponseCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Response.
     * @param {ResponseDeleteArgs} args - Arguments to delete one Response.
     * @example
     * // Delete one Response
     * const Response = await prisma.response.delete({
     *   where: {
     *     // ... filter to delete one Response
     *   }
     * })
     * 
    **/
    delete<T extends ResponseDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseDeleteArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Response.
     * @param {ResponseUpdateArgs} args - Arguments to update one Response.
     * @example
     * // Update one Response
     * const response = await prisma.response.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResponseUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseUpdateArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Responses.
     * @param {ResponseDeleteManyArgs} args - Arguments to filter Responses to delete.
     * @example
     * // Delete a few Responses
     * const { count } = await prisma.response.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResponseDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ResponseDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Responses
     * const response = await prisma.response.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResponseUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Response.
     * @param {ResponseUpsertArgs} args - Arguments to update or create a Response.
     * @example
     * // Update or create a Response
     * const response = await prisma.response.upsert({
     *   create: {
     *     // ... data to create a Response
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Response we want to update
     *   }
     * })
    **/
    upsert<T extends ResponseUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ResponseUpsertArgs<ExtArgs>>
    ): Prisma__ResponseClient<$Result.GetResult<Prisma.$ResponsePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Responses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseCountArgs} args - Arguments to filter Responses to count.
     * @example
     * // Count the number of Responses
     * const count = await prisma.response.count({
     *   where: {
     *     // ... the filter for the Responses we want to count
     *   }
     * })
    **/
    count<T extends ResponseCountArgs>(
      args?: Subset<T, ResponseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResponseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResponseAggregateArgs>(args: Subset<T, ResponseAggregateArgs>): Prisma.PrismaPromise<GetResponseAggregateType<T>>

    /**
     * Group by Response.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResponseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResponseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResponseGroupByArgs['orderBy'] }
        : { orderBy?: ResponseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResponseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResponseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Response model
   */
  readonly fields: ResponseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Response.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ResponseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    foro<T extends ForoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForoDefaultArgs<ExtArgs>>): Prisma__ForoClient<$Result.GetResult<Prisma.$ForoPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    answer<T extends AnswerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AnswerDefaultArgs<ExtArgs>>): Prisma__AnswerClient<$Result.GetResult<Prisma.$AnswerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Response model
   */ 
  interface ResponseFieldRefs {
    readonly id: FieldRef<"Response", 'Int'>
    readonly message: FieldRef<"Response", 'String'>
    readonly foroId: FieldRef<"Response", 'Int'>
    readonly answerId: FieldRef<"Response", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Response findUnique
   */
  export type ResponseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }


  /**
   * Response findUniqueOrThrow
   */
  export type ResponseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where: ResponseWhereUniqueInput
  }


  /**
   * Response findFirst
   */
  export type ResponseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }


  /**
   * Response findFirstOrThrow
   */
  export type ResponseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Response to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Responses.
     */
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }


  /**
   * Response findMany
   */
  export type ResponseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter, which Responses to fetch.
     */
    where?: ResponseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Responses to fetch.
     */
    orderBy?: ResponseOrderByWithRelationInput | ResponseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Responses.
     */
    cursor?: ResponseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Responses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Responses.
     */
    skip?: number
    distinct?: ResponseScalarFieldEnum | ResponseScalarFieldEnum[]
  }


  /**
   * Response create
   */
  export type ResponseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to create a Response.
     */
    data: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
  }


  /**
   * Response createMany
   */
  export type ResponseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Responses.
     */
    data: ResponseCreateManyInput | ResponseCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Response update
   */
  export type ResponseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The data needed to update a Response.
     */
    data: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
    /**
     * Choose, which Response to update.
     */
    where: ResponseWhereUniqueInput
  }


  /**
   * Response updateMany
   */
  export type ResponseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Responses.
     */
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyInput>
    /**
     * Filter which Responses to update
     */
    where?: ResponseWhereInput
  }


  /**
   * Response upsert
   */
  export type ResponseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * The filter to search for the Response to update in case it exists.
     */
    where: ResponseWhereUniqueInput
    /**
     * In case the Response found by the `where` argument doesn't exist, create a new Response with this data.
     */
    create: XOR<ResponseCreateInput, ResponseUncheckedCreateInput>
    /**
     * In case the Response was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ResponseUpdateInput, ResponseUncheckedUpdateInput>
  }


  /**
   * Response delete
   */
  export type ResponseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
    /**
     * Filter which Response to delete.
     */
    where: ResponseWhereUniqueInput
  }


  /**
   * Response deleteMany
   */
  export type ResponseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Responses to delete
     */
    where?: ResponseWhereInput
  }


  /**
   * Response without action
   */
  export type ResponseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Response
     */
    select?: ResponseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ResponseInclude<ExtArgs> | null
  }



  /**
   * Model Rol
   */

  export type AggregateRol = {
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  export type RolAvgAggregateOutputType = {
    id: number | null
  }

  export type RolSumAggregateOutputType = {
    id: number | null
  }

  export type RolMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type RolCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type RolAvgAggregateInputType = {
    id?: true
  }

  export type RolSumAggregateInputType = {
    id?: true
  }

  export type RolMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type RolCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type RolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rol to aggregate.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rols
    **/
    _count?: true | RolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolMaxAggregateInputType
  }

  export type GetRolAggregateType<T extends RolAggregateArgs> = {
        [P in keyof T & keyof AggregateRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRol[P]>
      : GetScalarType<T[P], AggregateRol[P]>
  }




  export type RolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolWhereInput
    orderBy?: RolOrderByWithAggregationInput | RolOrderByWithAggregationInput[]
    by: RolScalarFieldEnum[] | RolScalarFieldEnum
    having?: RolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolCountAggregateInputType | true
    _avg?: RolAvgAggregateInputType
    _sum?: RolSumAggregateInputType
    _min?: RolMinAggregateInputType
    _max?: RolMaxAggregateInputType
  }

  export type RolGroupByOutputType = {
    id: number
    name: string
    _count: RolCountAggregateOutputType | null
    _avg: RolAvgAggregateOutputType | null
    _sum: RolSumAggregateOutputType | null
    _min: RolMinAggregateOutputType | null
    _max: RolMaxAggregateOutputType | null
  }

  type GetRolGroupByPayload<T extends RolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolGroupByOutputType[P]>
            : GetScalarType<T[P], RolGroupByOutputType[P]>
        }
      >
    >


  export type RolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    links?: boolean | Rol$linksArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rol"]>

  export type RolSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type RolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    links?: boolean | Rol$linksArgs<ExtArgs>
    _count?: boolean | RolCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Rol"
    objects: {
      links: Prisma.$LinkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["rol"]>
    composites: {}
  }


  type RolGetPayload<S extends boolean | null | undefined | RolDefaultArgs> = $Result.GetResult<Prisma.$RolPayload, S>

  type RolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RolFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: RolCountAggregateInputType | true
    }

  export interface RolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Rol'], meta: { name: 'Rol' } }
    /**
     * Find zero or one Rol that matches the filter.
     * @param {RolFindUniqueArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RolFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RolFindUniqueArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Rol that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RolFindUniqueOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RolFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Rol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RolFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RolFindFirstArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Rol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindFirstOrThrowArgs} args - Arguments to find a Rol
     * @example
     * // Get one Rol
     * const rol = await prisma.rol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RolFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RolFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Rols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rols
     * const rols = await prisma.rol.findMany()
     * 
     * // Get first 10 Rols
     * const rols = await prisma.rol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolWithIdOnly = await prisma.rol.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RolFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Rol.
     * @param {RolCreateArgs} args - Arguments to create a Rol.
     * @example
     * // Create one Rol
     * const Rol = await prisma.rol.create({
     *   data: {
     *     // ... data to create a Rol
     *   }
     * })
     * 
    **/
    create<T extends RolCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RolCreateArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Rols.
     *     @param {RolCreateManyArgs} args - Arguments to create many Rols.
     *     @example
     *     // Create many Rols
     *     const rol = await prisma.rol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RolCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rol.
     * @param {RolDeleteArgs} args - Arguments to delete one Rol.
     * @example
     * // Delete one Rol
     * const Rol = await prisma.rol.delete({
     *   where: {
     *     // ... filter to delete one Rol
     *   }
     * })
     * 
    **/
    delete<T extends RolDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RolDeleteArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Rol.
     * @param {RolUpdateArgs} args - Arguments to update one Rol.
     * @example
     * // Update one Rol
     * const rol = await prisma.rol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RolUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RolUpdateArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Rols.
     * @param {RolDeleteManyArgs} args - Arguments to filter Rols to delete.
     * @example
     * // Delete a few Rols
     * const { count } = await prisma.rol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RolDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RolDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rols
     * const rol = await prisma.rol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RolUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RolUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rol.
     * @param {RolUpsertArgs} args - Arguments to update or create a Rol.
     * @example
     * // Update or create a Rol
     * const rol = await prisma.rol.upsert({
     *   create: {
     *     // ... data to create a Rol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rol we want to update
     *   }
     * })
    **/
    upsert<T extends RolUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RolUpsertArgs<ExtArgs>>
    ): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Rols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolCountArgs} args - Arguments to filter Rols to count.
     * @example
     * // Count the number of Rols
     * const count = await prisma.rol.count({
     *   where: {
     *     // ... the filter for the Rols we want to count
     *   }
     * })
    **/
    count<T extends RolCountArgs>(
      args?: Subset<T, RolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolAggregateArgs>(args: Subset<T, RolAggregateArgs>): Prisma.PrismaPromise<GetRolAggregateType<T>>

    /**
     * Group by Rol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolGroupByArgs['orderBy'] }
        : { orderBy?: RolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Rol model
   */
  readonly fields: RolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Rol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    links<T extends Rol$linksArgs<ExtArgs> = {}>(args?: Subset<T, Rol$linksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Rol model
   */ 
  interface RolFieldRefs {
    readonly id: FieldRef<"Rol", 'Int'>
    readonly name: FieldRef<"Rol", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Rol findUnique
   */
  export type RolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }


  /**
   * Rol findUniqueOrThrow
   */
  export type RolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where: RolWhereUniqueInput
  }


  /**
   * Rol findFirst
   */
  export type RolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * Rol findFirstOrThrow
   */
  export type RolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rol to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rols.
     */
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * Rol findMany
   */
  export type RolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter, which Rols to fetch.
     */
    where?: RolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rols to fetch.
     */
    orderBy?: RolOrderByWithRelationInput | RolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rols.
     */
    cursor?: RolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rols.
     */
    skip?: number
    distinct?: RolScalarFieldEnum | RolScalarFieldEnum[]
  }


  /**
   * Rol create
   */
  export type RolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to create a Rol.
     */
    data: XOR<RolCreateInput, RolUncheckedCreateInput>
  }


  /**
   * Rol createMany
   */
  export type RolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rols.
     */
    data: RolCreateManyInput | RolCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Rol update
   */
  export type RolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The data needed to update a Rol.
     */
    data: XOR<RolUpdateInput, RolUncheckedUpdateInput>
    /**
     * Choose, which Rol to update.
     */
    where: RolWhereUniqueInput
  }


  /**
   * Rol updateMany
   */
  export type RolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rols.
     */
    data: XOR<RolUpdateManyMutationInput, RolUncheckedUpdateManyInput>
    /**
     * Filter which Rols to update
     */
    where?: RolWhereInput
  }


  /**
   * Rol upsert
   */
  export type RolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * The filter to search for the Rol to update in case it exists.
     */
    where: RolWhereUniqueInput
    /**
     * In case the Rol found by the `where` argument doesn't exist, create a new Rol with this data.
     */
    create: XOR<RolCreateInput, RolUncheckedCreateInput>
    /**
     * In case the Rol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolUpdateInput, RolUncheckedUpdateInput>
  }


  /**
   * Rol delete
   */
  export type RolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
    /**
     * Filter which Rol to delete.
     */
    where: RolWhereUniqueInput
  }


  /**
   * Rol deleteMany
   */
  export type RolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rols to delete
     */
    where?: RolWhereInput
  }


  /**
   * Rol.links
   */
  export type Rol$linksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    where?: LinkWhereInput
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    cursor?: LinkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }


  /**
   * Rol without action
   */
  export type RolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Rol
     */
    select?: RolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RolInclude<ExtArgs> | null
  }



  /**
   * Model Link
   */

  export type AggregateLink = {
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  export type LinkAvgAggregateOutputType = {
    id: number | null
    rolId: number | null
  }

  export type LinkSumAggregateOutputType = {
    id: number | null
    rolId: number | null
  }

  export type LinkMinAggregateOutputType = {
    id: number | null
    rolId: number | null
    name: string | null
    Link: string | null
  }

  export type LinkMaxAggregateOutputType = {
    id: number | null
    rolId: number | null
    name: string | null
    Link: string | null
  }

  export type LinkCountAggregateOutputType = {
    id: number
    rolId: number
    name: number
    Link: number
    _all: number
  }


  export type LinkAvgAggregateInputType = {
    id?: true
    rolId?: true
  }

  export type LinkSumAggregateInputType = {
    id?: true
    rolId?: true
  }

  export type LinkMinAggregateInputType = {
    id?: true
    rolId?: true
    name?: true
    Link?: true
  }

  export type LinkMaxAggregateInputType = {
    id?: true
    rolId?: true
    name?: true
    Link?: true
  }

  export type LinkCountAggregateInputType = {
    id?: true
    rolId?: true
    name?: true
    Link?: true
    _all?: true
  }

  export type LinkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Link to aggregate.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Links
    **/
    _count?: true | LinkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkMaxAggregateInputType
  }

  export type GetLinkAggregateType<T extends LinkAggregateArgs> = {
        [P in keyof T & keyof AggregateLink]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLink[P]>
      : GetScalarType<T[P], AggregateLink[P]>
  }




  export type LinkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkWhereInput
    orderBy?: LinkOrderByWithAggregationInput | LinkOrderByWithAggregationInput[]
    by: LinkScalarFieldEnum[] | LinkScalarFieldEnum
    having?: LinkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkCountAggregateInputType | true
    _avg?: LinkAvgAggregateInputType
    _sum?: LinkSumAggregateInputType
    _min?: LinkMinAggregateInputType
    _max?: LinkMaxAggregateInputType
  }

  export type LinkGroupByOutputType = {
    id: number
    rolId: number
    name: string
    Link: string
    _count: LinkCountAggregateOutputType | null
    _avg: LinkAvgAggregateOutputType | null
    _sum: LinkSumAggregateOutputType | null
    _min: LinkMinAggregateOutputType | null
    _max: LinkMaxAggregateOutputType | null
  }

  type GetLinkGroupByPayload<T extends LinkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkGroupByOutputType[P]>
            : GetScalarType<T[P], LinkGroupByOutputType[P]>
        }
      >
    >


  export type LinkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rolId?: boolean
    name?: boolean
    Link?: boolean
    rol?: boolean | RolDefaultArgs<ExtArgs>
    userLineLink?: boolean | Link$userLineLinkArgs<ExtArgs>
    _count?: boolean | LinkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["link"]>

  export type LinkSelectScalar = {
    id?: boolean
    rolId?: boolean
    name?: boolean
    Link?: boolean
  }

  export type LinkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rol?: boolean | RolDefaultArgs<ExtArgs>
    userLineLink?: boolean | Link$userLineLinkArgs<ExtArgs>
    _count?: boolean | LinkCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $LinkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Link"
    objects: {
      rol: Prisma.$RolPayload<ExtArgs>
      userLineLink: Prisma.$user_line_linkPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rolId: number
      name: string
      Link: string
    }, ExtArgs["result"]["link"]>
    composites: {}
  }


  type LinkGetPayload<S extends boolean | null | undefined | LinkDefaultArgs> = $Result.GetResult<Prisma.$LinkPayload, S>

  type LinkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LinkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: LinkCountAggregateInputType | true
    }

  export interface LinkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Link'], meta: { name: 'Link' } }
    /**
     * Find zero or one Link that matches the filter.
     * @param {LinkFindUniqueArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LinkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LinkFindUniqueArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Link that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LinkFindUniqueOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LinkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LinkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkFindFirstArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindFirstOrThrowArgs} args - Arguments to find a Link
     * @example
     * // Get one Link
     * const link = await prisma.link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LinkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Links
     * const links = await prisma.link.findMany()
     * 
     * // Get first 10 Links
     * const links = await prisma.link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkWithIdOnly = await prisma.link.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LinkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Link.
     * @param {LinkCreateArgs} args - Arguments to create a Link.
     * @example
     * // Create one Link
     * const Link = await prisma.link.create({
     *   data: {
     *     // ... data to create a Link
     *   }
     * })
     * 
    **/
    create<T extends LinkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LinkCreateArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Links.
     *     @param {LinkCreateManyArgs} args - Arguments to create many Links.
     *     @example
     *     // Create many Links
     *     const link = await prisma.link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LinkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Link.
     * @param {LinkDeleteArgs} args - Arguments to delete one Link.
     * @example
     * // Delete one Link
     * const Link = await prisma.link.delete({
     *   where: {
     *     // ... filter to delete one Link
     *   }
     * })
     * 
    **/
    delete<T extends LinkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LinkDeleteArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Link.
     * @param {LinkUpdateArgs} args - Arguments to update one Link.
     * @example
     * // Update one Link
     * const link = await prisma.link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LinkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LinkUpdateArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Links.
     * @param {LinkDeleteManyArgs} args - Arguments to filter Links to delete.
     * @example
     * // Delete a few Links
     * const { count } = await prisma.link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LinkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LinkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Links
     * const link = await prisma.link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LinkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LinkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Link.
     * @param {LinkUpsertArgs} args - Arguments to update or create a Link.
     * @example
     * // Update or create a Link
     * const link = await prisma.link.upsert({
     *   create: {
     *     // ... data to create a Link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Link we want to update
     *   }
     * })
    **/
    upsert<T extends LinkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LinkUpsertArgs<ExtArgs>>
    ): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkCountArgs} args - Arguments to filter Links to count.
     * @example
     * // Count the number of Links
     * const count = await prisma.link.count({
     *   where: {
     *     // ... the filter for the Links we want to count
     *   }
     * })
    **/
    count<T extends LinkCountArgs>(
      args?: Subset<T, LinkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkAggregateArgs>(args: Subset<T, LinkAggregateArgs>): Prisma.PrismaPromise<GetLinkAggregateType<T>>

    /**
     * Group by Link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkGroupByArgs['orderBy'] }
        : { orderBy?: LinkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Link model
   */
  readonly fields: LinkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    rol<T extends RolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RolDefaultArgs<ExtArgs>>): Prisma__RolClient<$Result.GetResult<Prisma.$RolPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    userLineLink<T extends Link$userLineLinkArgs<ExtArgs> = {}>(args?: Subset<T, Link$userLineLinkArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Link model
   */ 
  interface LinkFieldRefs {
    readonly id: FieldRef<"Link", 'Int'>
    readonly rolId: FieldRef<"Link", 'Int'>
    readonly name: FieldRef<"Link", 'String'>
    readonly Link: FieldRef<"Link", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Link findUnique
   */
  export type LinkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link findUniqueOrThrow
   */
  export type LinkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link findFirst
   */
  export type LinkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }


  /**
   * Link findFirstOrThrow
   */
  export type LinkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Link to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Links.
     */
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }


  /**
   * Link findMany
   */
  export type LinkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter, which Links to fetch.
     */
    where?: LinkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Links to fetch.
     */
    orderBy?: LinkOrderByWithRelationInput | LinkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Links.
     */
    cursor?: LinkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Links.
     */
    skip?: number
    distinct?: LinkScalarFieldEnum | LinkScalarFieldEnum[]
  }


  /**
   * Link create
   */
  export type LinkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The data needed to create a Link.
     */
    data: XOR<LinkCreateInput, LinkUncheckedCreateInput>
  }


  /**
   * Link createMany
   */
  export type LinkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Links.
     */
    data: LinkCreateManyInput | LinkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Link update
   */
  export type LinkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The data needed to update a Link.
     */
    data: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
    /**
     * Choose, which Link to update.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link updateMany
   */
  export type LinkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Links.
     */
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyInput>
    /**
     * Filter which Links to update
     */
    where?: LinkWhereInput
  }


  /**
   * Link upsert
   */
  export type LinkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * The filter to search for the Link to update in case it exists.
     */
    where: LinkWhereUniqueInput
    /**
     * In case the Link found by the `where` argument doesn't exist, create a new Link with this data.
     */
    create: XOR<LinkCreateInput, LinkUncheckedCreateInput>
    /**
     * In case the Link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkUpdateInput, LinkUncheckedUpdateInput>
  }


  /**
   * Link delete
   */
  export type LinkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
    /**
     * Filter which Link to delete.
     */
    where: LinkWhereUniqueInput
  }


  /**
   * Link deleteMany
   */
  export type LinkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Links to delete
     */
    where?: LinkWhereInput
  }


  /**
   * Link.userLineLink
   */
  export type Link$userLineLinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    where?: user_line_linkWhereInput
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    cursor?: user_line_linkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_line_linkScalarFieldEnum | User_line_linkScalarFieldEnum[]
  }


  /**
   * Link without action
   */
  export type LinkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Link
     */
    select?: LinkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LinkInclude<ExtArgs> | null
  }



  /**
   * Model user_line_link
   */

  export type AggregateUser_line_link = {
    _count: User_line_linkCountAggregateOutputType | null
    _avg: User_line_linkAvgAggregateOutputType | null
    _sum: User_line_linkSumAggregateOutputType | null
    _min: User_line_linkMinAggregateOutputType | null
    _max: User_line_linkMaxAggregateOutputType | null
  }

  export type User_line_linkAvgAggregateOutputType = {
    id: number | null
    linkId: number | null
    userId: number | null
  }

  export type User_line_linkSumAggregateOutputType = {
    id: number | null
    linkId: number | null
    userId: number | null
  }

  export type User_line_linkMinAggregateOutputType = {
    id: number | null
    linkId: number | null
    userId: number | null
  }

  export type User_line_linkMaxAggregateOutputType = {
    id: number | null
    linkId: number | null
    userId: number | null
  }

  export type User_line_linkCountAggregateOutputType = {
    id: number
    linkId: number
    userId: number
    _all: number
  }


  export type User_line_linkAvgAggregateInputType = {
    id?: true
    linkId?: true
    userId?: true
  }

  export type User_line_linkSumAggregateInputType = {
    id?: true
    linkId?: true
    userId?: true
  }

  export type User_line_linkMinAggregateInputType = {
    id?: true
    linkId?: true
    userId?: true
  }

  export type User_line_linkMaxAggregateInputType = {
    id?: true
    linkId?: true
    userId?: true
  }

  export type User_line_linkCountAggregateInputType = {
    id?: true
    linkId?: true
    userId?: true
    _all?: true
  }

  export type User_line_linkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_line_link to aggregate.
     */
    where?: user_line_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_line_links to fetch.
     */
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_line_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_line_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_line_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_line_links
    **/
    _count?: true | User_line_linkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_line_linkAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_line_linkSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_line_linkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_line_linkMaxAggregateInputType
  }

  export type GetUser_line_linkAggregateType<T extends User_line_linkAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_line_link]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_line_link[P]>
      : GetScalarType<T[P], AggregateUser_line_link[P]>
  }




  export type user_line_linkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_line_linkWhereInput
    orderBy?: user_line_linkOrderByWithAggregationInput | user_line_linkOrderByWithAggregationInput[]
    by: User_line_linkScalarFieldEnum[] | User_line_linkScalarFieldEnum
    having?: user_line_linkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_line_linkCountAggregateInputType | true
    _avg?: User_line_linkAvgAggregateInputType
    _sum?: User_line_linkSumAggregateInputType
    _min?: User_line_linkMinAggregateInputType
    _max?: User_line_linkMaxAggregateInputType
  }

  export type User_line_linkGroupByOutputType = {
    id: number
    linkId: number
    userId: number
    _count: User_line_linkCountAggregateOutputType | null
    _avg: User_line_linkAvgAggregateOutputType | null
    _sum: User_line_linkSumAggregateOutputType | null
    _min: User_line_linkMinAggregateOutputType | null
    _max: User_line_linkMaxAggregateOutputType | null
  }

  type GetUser_line_linkGroupByPayload<T extends user_line_linkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_line_linkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_line_linkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_line_linkGroupByOutputType[P]>
            : GetScalarType<T[P], User_line_linkGroupByOutputType[P]>
        }
      >
    >


  export type user_line_linkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkId?: boolean
    userId?: boolean
    link?: boolean | LinkDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_line_link"]>

  export type user_line_linkSelectScalar = {
    id?: boolean
    linkId?: boolean
    userId?: boolean
  }

  export type user_line_linkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    link?: boolean | LinkDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }


  export type $user_line_linkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_line_link"
    objects: {
      link: Prisma.$LinkPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      linkId: number
      userId: number
    }, ExtArgs["result"]["user_line_link"]>
    composites: {}
  }


  type user_line_linkGetPayload<S extends boolean | null | undefined | user_line_linkDefaultArgs> = $Result.GetResult<Prisma.$user_line_linkPayload, S>

  type user_line_linkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_line_linkFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: User_line_linkCountAggregateInputType | true
    }

  export interface user_line_linkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_line_link'], meta: { name: 'user_line_link' } }
    /**
     * Find zero or one User_line_link that matches the filter.
     * @param {user_line_linkFindUniqueArgs} args - Arguments to find a User_line_link
     * @example
     * // Get one User_line_link
     * const user_line_link = await prisma.user_line_link.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_line_linkFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkFindUniqueArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User_line_link that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {user_line_linkFindUniqueOrThrowArgs} args - Arguments to find a User_line_link
     * @example
     * // Get one User_line_link
     * const user_line_link = await prisma.user_line_link.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_line_linkFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User_line_link that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkFindFirstArgs} args - Arguments to find a User_line_link
     * @example
     * // Get one User_line_link
     * const user_line_link = await prisma.user_line_link.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_line_linkFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkFindFirstArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User_line_link that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkFindFirstOrThrowArgs} args - Arguments to find a User_line_link
     * @example
     * // Get one User_line_link
     * const user_line_link = await prisma.user_line_link.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_line_linkFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more User_line_links that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_line_links
     * const user_line_links = await prisma.user_line_link.findMany()
     * 
     * // Get first 10 User_line_links
     * const user_line_links = await prisma.user_line_link.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_line_linkWithIdOnly = await prisma.user_line_link.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_line_linkFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User_line_link.
     * @param {user_line_linkCreateArgs} args - Arguments to create a User_line_link.
     * @example
     * // Create one User_line_link
     * const User_line_link = await prisma.user_line_link.create({
     *   data: {
     *     // ... data to create a User_line_link
     *   }
     * })
     * 
    **/
    create<T extends user_line_linkCreateArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkCreateArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many User_line_links.
     *     @param {user_line_linkCreateManyArgs} args - Arguments to create many User_line_links.
     *     @example
     *     // Create many User_line_links
     *     const user_line_link = await prisma.user_line_link.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_line_linkCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_line_link.
     * @param {user_line_linkDeleteArgs} args - Arguments to delete one User_line_link.
     * @example
     * // Delete one User_line_link
     * const User_line_link = await prisma.user_line_link.delete({
     *   where: {
     *     // ... filter to delete one User_line_link
     *   }
     * })
     * 
    **/
    delete<T extends user_line_linkDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkDeleteArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User_line_link.
     * @param {user_line_linkUpdateArgs} args - Arguments to update one User_line_link.
     * @example
     * // Update one User_line_link
     * const user_line_link = await prisma.user_line_link.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_line_linkUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkUpdateArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more User_line_links.
     * @param {user_line_linkDeleteManyArgs} args - Arguments to filter User_line_links to delete.
     * @example
     * // Delete a few User_line_links
     * const { count } = await prisma.user_line_link.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_line_linkDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, user_line_linkDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_line_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_line_links
     * const user_line_link = await prisma.user_line_link.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_line_linkUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_line_link.
     * @param {user_line_linkUpsertArgs} args - Arguments to update or create a User_line_link.
     * @example
     * // Update or create a User_line_link
     * const user_line_link = await prisma.user_line_link.upsert({
     *   create: {
     *     // ... data to create a User_line_link
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_line_link we want to update
     *   }
     * })
    **/
    upsert<T extends user_line_linkUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, user_line_linkUpsertArgs<ExtArgs>>
    ): Prisma__user_line_linkClient<$Result.GetResult<Prisma.$user_line_linkPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of User_line_links.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkCountArgs} args - Arguments to filter User_line_links to count.
     * @example
     * // Count the number of User_line_links
     * const count = await prisma.user_line_link.count({
     *   where: {
     *     // ... the filter for the User_line_links we want to count
     *   }
     * })
    **/
    count<T extends user_line_linkCountArgs>(
      args?: Subset<T, user_line_linkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_line_linkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_line_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_line_linkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_line_linkAggregateArgs>(args: Subset<T, User_line_linkAggregateArgs>): Prisma.PrismaPromise<GetUser_line_linkAggregateType<T>>

    /**
     * Group by User_line_link.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_line_linkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_line_linkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_line_linkGroupByArgs['orderBy'] }
        : { orderBy?: user_line_linkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_line_linkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_line_linkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_line_link model
   */
  readonly fields: user_line_linkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_line_link.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_line_linkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    link<T extends LinkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinkDefaultArgs<ExtArgs>>): Prisma__LinkClient<$Result.GetResult<Prisma.$LinkPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the user_line_link model
   */ 
  interface user_line_linkFieldRefs {
    readonly id: FieldRef<"user_line_link", 'Int'>
    readonly linkId: FieldRef<"user_line_link", 'Int'>
    readonly userId: FieldRef<"user_line_link", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * user_line_link findUnique
   */
  export type user_line_linkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter, which user_line_link to fetch.
     */
    where: user_line_linkWhereUniqueInput
  }


  /**
   * user_line_link findUniqueOrThrow
   */
  export type user_line_linkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter, which user_line_link to fetch.
     */
    where: user_line_linkWhereUniqueInput
  }


  /**
   * user_line_link findFirst
   */
  export type user_line_linkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter, which user_line_link to fetch.
     */
    where?: user_line_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_line_links to fetch.
     */
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_line_links.
     */
    cursor?: user_line_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_line_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_line_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_line_links.
     */
    distinct?: User_line_linkScalarFieldEnum | User_line_linkScalarFieldEnum[]
  }


  /**
   * user_line_link findFirstOrThrow
   */
  export type user_line_linkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter, which user_line_link to fetch.
     */
    where?: user_line_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_line_links to fetch.
     */
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_line_links.
     */
    cursor?: user_line_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_line_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_line_links.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_line_links.
     */
    distinct?: User_line_linkScalarFieldEnum | User_line_linkScalarFieldEnum[]
  }


  /**
   * user_line_link findMany
   */
  export type user_line_linkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter, which user_line_links to fetch.
     */
    where?: user_line_linkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_line_links to fetch.
     */
    orderBy?: user_line_linkOrderByWithRelationInput | user_line_linkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_line_links.
     */
    cursor?: user_line_linkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_line_links from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_line_links.
     */
    skip?: number
    distinct?: User_line_linkScalarFieldEnum | User_line_linkScalarFieldEnum[]
  }


  /**
   * user_line_link create
   */
  export type user_line_linkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * The data needed to create a user_line_link.
     */
    data: XOR<user_line_linkCreateInput, user_line_linkUncheckedCreateInput>
  }


  /**
   * user_line_link createMany
   */
  export type user_line_linkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_line_links.
     */
    data: user_line_linkCreateManyInput | user_line_linkCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * user_line_link update
   */
  export type user_line_linkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * The data needed to update a user_line_link.
     */
    data: XOR<user_line_linkUpdateInput, user_line_linkUncheckedUpdateInput>
    /**
     * Choose, which user_line_link to update.
     */
    where: user_line_linkWhereUniqueInput
  }


  /**
   * user_line_link updateMany
   */
  export type user_line_linkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_line_links.
     */
    data: XOR<user_line_linkUpdateManyMutationInput, user_line_linkUncheckedUpdateManyInput>
    /**
     * Filter which user_line_links to update
     */
    where?: user_line_linkWhereInput
  }


  /**
   * user_line_link upsert
   */
  export type user_line_linkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * The filter to search for the user_line_link to update in case it exists.
     */
    where: user_line_linkWhereUniqueInput
    /**
     * In case the user_line_link found by the `where` argument doesn't exist, create a new user_line_link with this data.
     */
    create: XOR<user_line_linkCreateInput, user_line_linkUncheckedCreateInput>
    /**
     * In case the user_line_link was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_line_linkUpdateInput, user_line_linkUncheckedUpdateInput>
  }


  /**
   * user_line_link delete
   */
  export type user_line_linkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
    /**
     * Filter which user_line_link to delete.
     */
    where: user_line_linkWhereUniqueInput
  }


  /**
   * user_line_link deleteMany
   */
  export type user_line_linkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_line_links to delete
     */
    where?: user_line_linkWhereInput
  }


  /**
   * user_line_link without action
   */
  export type user_line_linkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_line_link
     */
    select?: user_line_linkSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: user_line_linkInclude<ExtArgs> | null
  }



  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    description: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    description: string | null
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Category$productsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
    }, ExtArgs["result"]["category"]>
    composites: {}
  }


  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CategoryFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CategoryFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CategoryFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
    **/
    create<T extends CategoryCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Categories.
     *     @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     *     @example
     *     // Create many Categories
     *     const category = await prisma.category.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CategoryCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
    **/
    delete<T extends CategoryDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CategoryUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CategoryDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CategoryUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
    **/
    upsert<T extends CategoryUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>
    ): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends Category$productsArgs<ExtArgs> = {}>(args?: Subset<T, Category$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly description: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }


  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }


  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }


  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }


  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }


  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }


  /**
   * Category.products
   */
  export type Category$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
  }



  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    id: number | null
  }

  export type ServiceSumAggregateOutputType = {
    id: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: number | null
    name: string | null
    DATE_START: Date | null
    DATE_END: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: number | null
    name: string | null
    DATE_START: Date | null
    DATE_END: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    name: number
    DATE_START: number
    DATE_END: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    id?: true
  }

  export type ServiceSumAggregateInputType = {
    id?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    name?: true
    DATE_START?: true
    DATE_END?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    name?: true
    DATE_START?: true
    DATE_END?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    name?: true
    DATE_START?: true
    DATE_END?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: number
    name: string
    DATE_START: Date | null
    DATE_END: Date | null
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    DATE_START?: boolean
    DATE_END?: boolean
    products?: boolean | Service$productsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    name?: boolean
    DATE_START?: boolean
    DATE_END?: boolean
  }

  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Service$productsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      DATE_START: Date | null
      DATE_END: Date | null
    }, ExtArgs["result"]["service"]>
    composites: {}
  }


  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Service that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
    **/
    create<T extends ServiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Services.
     *     @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     *     @example
     *     // Create many Services
     *     const service = await prisma.service.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
    **/
    delete<T extends ServiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
    **/
    upsert<T extends ServiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>
    ): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    products<T extends Service$productsArgs<ExtArgs> = {}>(args?: Subset<T, Service$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Service model
   */ 
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly DATE_START: FieldRef<"Service", 'DateTime'>
    readonly DATE_END: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }


  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }


  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
  }


  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }


  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }


  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
  }


  /**
   * Service.products
   */
  export type Service$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
  }



  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    serviceid: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    serviceid: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    serviceid: number | null
    name: string | null
    description: string | null
    price: string | null
    date_create: string | null
    status: boolean | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    categoryId: number | null
    serviceid: number | null
    name: string | null
    description: string | null
    price: string | null
    date_create: string | null
    status: boolean | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    userId: number
    categoryId: number
    serviceid: number
    name: number
    description: number
    price: number
    date_create: number
    status: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    serviceid?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    serviceid?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    serviceid?: true
    name?: true
    description?: true
    price?: true
    date_create?: true
    status?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    serviceid?: true
    name?: true
    description?: true
    price?: true
    date_create?: true
    status?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    userId?: true
    categoryId?: true
    serviceid?: true
    name?: true
    description?: true
    price?: true
    date_create?: true
    status?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    userId: number
    categoryId: number | null
    serviceid: number | null
    name: string
    description: string | null
    price: string | null
    date_create: string | null
    status: boolean | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    serviceid?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    date_create?: boolean
    status?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    service?: boolean | Product$serviceArgs<ExtArgs>
    inv_line_pros?: boolean | Product$inv_line_prosArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    userId?: boolean
    categoryId?: boolean
    serviceid?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    date_create?: boolean
    status?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    category?: boolean | Product$categoryArgs<ExtArgs>
    service?: boolean | Product$serviceArgs<ExtArgs>
    inv_line_pros?: boolean | Product$inv_line_prosArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      category: Prisma.$CategoryPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs> | null
      inv_line_pros: Prisma.$Inv_Line_ProPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      categoryId: number | null
      serviceid: number | null
      name: string
      description: string | null
      price: string | null
      date_create: string | null
      status: boolean | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }


  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductCreateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>
    ): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    category<T extends Product$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    service<T extends Product$serviceArgs<ExtArgs> = {}>(args?: Subset<T, Product$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    inv_line_pros<T extends Product$inv_line_prosArgs<ExtArgs> = {}>(args?: Subset<T, Product$inv_line_prosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly userId: FieldRef<"Product", 'Int'>
    readonly categoryId: FieldRef<"Product", 'Int'>
    readonly serviceid: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'String'>
    readonly date_create: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }


  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }


  /**
   * Product.category
   */
  export type Product$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }


  /**
   * Product.service
   */
  export type Product$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }


  /**
   * Product.inv_line_pros
   */
  export type Product$inv_line_prosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    where?: Inv_Line_ProWhereInput
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    cursor?: Inv_Line_ProWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inv_Line_ProScalarFieldEnum | Inv_Line_ProScalarFieldEnum[]
  }


  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ProductInclude<ExtArgs> | null
  }



  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    id: number | null
  }

  export type CustomerSumAggregateOutputType = {
    id: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    lname: string | null
    phone: string | null
    idCard: string | null
    Company: string | null
    city: string | null
    job: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    lname: string | null
    phone: string | null
    idCard: string | null
    Company: string | null
    city: string | null
    job: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    lname: number
    phone: number
    idCard: number
    Company: number
    city: number
    job: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    id?: true
  }

  export type CustomerSumAggregateInputType = {
    id?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    Company?: true
    city?: true
    job?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    Company?: true
    city?: true
    job?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    lname?: true
    phone?: true
    idCard?: true
    Company?: true
    city?: true
    job?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city: string | null
    job: string
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    lname?: boolean
    phone?: boolean
    idCard?: boolean
    Company?: boolean
    city?: boolean
    job?: boolean
    invices?: boolean | Customer$invicesArgs<ExtArgs>
    publications?: boolean | Customer$publicationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    lname?: boolean
    phone?: boolean
    idCard?: boolean
    Company?: boolean
    city?: boolean
    job?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invices?: boolean | Customer$invicesArgs<ExtArgs>
    publications?: boolean | Customer$publicationsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      invices: Prisma.$InvoicePayload<ExtArgs>[]
      publications: Prisma.$PublicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      lname: string
      phone: string
      idCard: string
      Company: string
      city: string | null
      job: string
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }


  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CustomerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CustomerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CustomerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
    **/
    create<T extends CustomerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Customers.
     *     @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     *     @example
     *     // Create many Customers
     *     const customer = await prisma.customer.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CustomerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
    **/
    delete<T extends CustomerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CustomerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CustomerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CustomerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
    **/
    upsert<T extends CustomerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>
    ): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    invices<T extends Customer$invicesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$invicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany'> | Null>;

    publications<T extends Customer$publicationsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$publicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'Int'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly lname: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly idCard: FieldRef<"Customer", 'String'>
    readonly Company: FieldRef<"Customer", 'String'>
    readonly city: FieldRef<"Customer", 'String'>
    readonly job: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }


  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }


  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }


  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }


  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }


  /**
   * Customer.invices
   */
  export type Customer$invicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Customer.publications
   */
  export type Customer$publicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    cursor?: PublicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }


  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
  }



  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    id: number | null
    customerId: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    date: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    date: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    customerId: number
    date: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type InvoiceSumAggregateInputType = {
    id?: true
    customerId?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    customerId?: true
    date?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: number
    customerId: number
    date: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    date?: boolean
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    inv_line_pros?: boolean | Invoice$inv_line_prosArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    customerId?: boolean
    date?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    inv_line_pros?: boolean | Invoice$inv_line_prosArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs>
      inv_line_pros: Prisma.$Inv_Line_ProPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number
      date: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }


  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends InvoiceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends InvoiceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends InvoiceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
    **/
    create<T extends InvoiceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Invoices.
     *     @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     *     @example
     *     // Create many Invoices
     *     const invoice = await prisma.invoice.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends InvoiceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
    **/
    delete<T extends InvoiceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends InvoiceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends InvoiceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends InvoiceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
    **/
    upsert<T extends InvoiceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>
    ): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    inv_line_pros<T extends Invoice$inv_line_prosArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$inv_line_prosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'Int'>
    readonly customerId: FieldRef<"Invoice", 'Int'>
    readonly date: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes

  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }


  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }


  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }


  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }


  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }


  /**
   * Invoice.inv_line_pros
   */
  export type Invoice$inv_line_prosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    where?: Inv_Line_ProWhereInput
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    cursor?: Inv_Line_ProWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Inv_Line_ProScalarFieldEnum | Inv_Line_ProScalarFieldEnum[]
  }


  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: InvoiceInclude<ExtArgs> | null
  }



  /**
   * Model Inv_Line_Pro
   */

  export type AggregateInv_Line_Pro = {
    _count: Inv_Line_ProCountAggregateOutputType | null
    _avg: Inv_Line_ProAvgAggregateOutputType | null
    _sum: Inv_Line_ProSumAggregateOutputType | null
    _min: Inv_Line_ProMinAggregateOutputType | null
    _max: Inv_Line_ProMaxAggregateOutputType | null
  }

  export type Inv_Line_ProAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    invoiceId: number | null
  }

  export type Inv_Line_ProSumAggregateOutputType = {
    id: number | null
    productId: number | null
    invoiceId: number | null
  }

  export type Inv_Line_ProMinAggregateOutputType = {
    id: number | null
    productId: number | null
    invoiceId: number | null
  }

  export type Inv_Line_ProMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    invoiceId: number | null
  }

  export type Inv_Line_ProCountAggregateOutputType = {
    id: number
    productId: number
    invoiceId: number
    _all: number
  }


  export type Inv_Line_ProAvgAggregateInputType = {
    id?: true
    productId?: true
    invoiceId?: true
  }

  export type Inv_Line_ProSumAggregateInputType = {
    id?: true
    productId?: true
    invoiceId?: true
  }

  export type Inv_Line_ProMinAggregateInputType = {
    id?: true
    productId?: true
    invoiceId?: true
  }

  export type Inv_Line_ProMaxAggregateInputType = {
    id?: true
    productId?: true
    invoiceId?: true
  }

  export type Inv_Line_ProCountAggregateInputType = {
    id?: true
    productId?: true
    invoiceId?: true
    _all?: true
  }

  export type Inv_Line_ProAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inv_Line_Pro to aggregate.
     */
    where?: Inv_Line_ProWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inv_Line_Pros to fetch.
     */
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Inv_Line_ProWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inv_Line_Pros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inv_Line_Pros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inv_Line_Pros
    **/
    _count?: true | Inv_Line_ProCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Inv_Line_ProAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Inv_Line_ProSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Inv_Line_ProMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Inv_Line_ProMaxAggregateInputType
  }

  export type GetInv_Line_ProAggregateType<T extends Inv_Line_ProAggregateArgs> = {
        [P in keyof T & keyof AggregateInv_Line_Pro]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInv_Line_Pro[P]>
      : GetScalarType<T[P], AggregateInv_Line_Pro[P]>
  }




  export type Inv_Line_ProGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Inv_Line_ProWhereInput
    orderBy?: Inv_Line_ProOrderByWithAggregationInput | Inv_Line_ProOrderByWithAggregationInput[]
    by: Inv_Line_ProScalarFieldEnum[] | Inv_Line_ProScalarFieldEnum
    having?: Inv_Line_ProScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Inv_Line_ProCountAggregateInputType | true
    _avg?: Inv_Line_ProAvgAggregateInputType
    _sum?: Inv_Line_ProSumAggregateInputType
    _min?: Inv_Line_ProMinAggregateInputType
    _max?: Inv_Line_ProMaxAggregateInputType
  }

  export type Inv_Line_ProGroupByOutputType = {
    id: number
    productId: number
    invoiceId: number
    _count: Inv_Line_ProCountAggregateOutputType | null
    _avg: Inv_Line_ProAvgAggregateOutputType | null
    _sum: Inv_Line_ProSumAggregateOutputType | null
    _min: Inv_Line_ProMinAggregateOutputType | null
    _max: Inv_Line_ProMaxAggregateOutputType | null
  }

  type GetInv_Line_ProGroupByPayload<T extends Inv_Line_ProGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Inv_Line_ProGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Inv_Line_ProGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Inv_Line_ProGroupByOutputType[P]>
            : GetScalarType<T[P], Inv_Line_ProGroupByOutputType[P]>
        }
      >
    >


  export type Inv_Line_ProSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    invoiceId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inv_Line_Pro"]>

  export type Inv_Line_ProSelectScalar = {
    id?: boolean
    productId?: boolean
    invoiceId?: boolean
  }

  export type Inv_Line_ProInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }


  export type $Inv_Line_ProPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inv_Line_Pro"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      invoiceId: number
    }, ExtArgs["result"]["inv_Line_Pro"]>
    composites: {}
  }


  type Inv_Line_ProGetPayload<S extends boolean | null | undefined | Inv_Line_ProDefaultArgs> = $Result.GetResult<Prisma.$Inv_Line_ProPayload, S>

  type Inv_Line_ProCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Inv_Line_ProFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: Inv_Line_ProCountAggregateInputType | true
    }

  export interface Inv_Line_ProDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inv_Line_Pro'], meta: { name: 'Inv_Line_Pro' } }
    /**
     * Find zero or one Inv_Line_Pro that matches the filter.
     * @param {Inv_Line_ProFindUniqueArgs} args - Arguments to find a Inv_Line_Pro
     * @example
     * // Get one Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Inv_Line_ProFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProFindUniqueArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Inv_Line_Pro that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Inv_Line_ProFindUniqueOrThrowArgs} args - Arguments to find a Inv_Line_Pro
     * @example
     * // Get one Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Inv_Line_ProFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Inv_Line_Pro that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProFindFirstArgs} args - Arguments to find a Inv_Line_Pro
     * @example
     * // Get one Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Inv_Line_ProFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProFindFirstArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Inv_Line_Pro that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProFindFirstOrThrowArgs} args - Arguments to find a Inv_Line_Pro
     * @example
     * // Get one Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Inv_Line_ProFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Inv_Line_Pros that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inv_Line_Pros
     * const inv_Line_Pros = await prisma.inv_Line_Pro.findMany()
     * 
     * // Get first 10 Inv_Line_Pros
     * const inv_Line_Pros = await prisma.inv_Line_Pro.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inv_Line_ProWithIdOnly = await prisma.inv_Line_Pro.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Inv_Line_ProFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Inv_Line_Pro.
     * @param {Inv_Line_ProCreateArgs} args - Arguments to create a Inv_Line_Pro.
     * @example
     * // Create one Inv_Line_Pro
     * const Inv_Line_Pro = await prisma.inv_Line_Pro.create({
     *   data: {
     *     // ... data to create a Inv_Line_Pro
     *   }
     * })
     * 
    **/
    create<T extends Inv_Line_ProCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProCreateArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Inv_Line_Pros.
     *     @param {Inv_Line_ProCreateManyArgs} args - Arguments to create many Inv_Line_Pros.
     *     @example
     *     // Create many Inv_Line_Pros
     *     const inv_Line_Pro = await prisma.inv_Line_Pro.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Inv_Line_ProCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Inv_Line_Pro.
     * @param {Inv_Line_ProDeleteArgs} args - Arguments to delete one Inv_Line_Pro.
     * @example
     * // Delete one Inv_Line_Pro
     * const Inv_Line_Pro = await prisma.inv_Line_Pro.delete({
     *   where: {
     *     // ... filter to delete one Inv_Line_Pro
     *   }
     * })
     * 
    **/
    delete<T extends Inv_Line_ProDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProDeleteArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Inv_Line_Pro.
     * @param {Inv_Line_ProUpdateArgs} args - Arguments to update one Inv_Line_Pro.
     * @example
     * // Update one Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Inv_Line_ProUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProUpdateArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Inv_Line_Pros.
     * @param {Inv_Line_ProDeleteManyArgs} args - Arguments to filter Inv_Line_Pros to delete.
     * @example
     * // Delete a few Inv_Line_Pros
     * const { count } = await prisma.inv_Line_Pro.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Inv_Line_ProDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Inv_Line_ProDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inv_Line_Pros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inv_Line_Pros
     * const inv_Line_Pro = await prisma.inv_Line_Pro.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Inv_Line_ProUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Inv_Line_Pro.
     * @param {Inv_Line_ProUpsertArgs} args - Arguments to update or create a Inv_Line_Pro.
     * @example
     * // Update or create a Inv_Line_Pro
     * const inv_Line_Pro = await prisma.inv_Line_Pro.upsert({
     *   create: {
     *     // ... data to create a Inv_Line_Pro
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inv_Line_Pro we want to update
     *   }
     * })
    **/
    upsert<T extends Inv_Line_ProUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Inv_Line_ProUpsertArgs<ExtArgs>>
    ): Prisma__Inv_Line_ProClient<$Result.GetResult<Prisma.$Inv_Line_ProPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Inv_Line_Pros.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProCountArgs} args - Arguments to filter Inv_Line_Pros to count.
     * @example
     * // Count the number of Inv_Line_Pros
     * const count = await prisma.inv_Line_Pro.count({
     *   where: {
     *     // ... the filter for the Inv_Line_Pros we want to count
     *   }
     * })
    **/
    count<T extends Inv_Line_ProCountArgs>(
      args?: Subset<T, Inv_Line_ProCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Inv_Line_ProCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inv_Line_Pro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Inv_Line_ProAggregateArgs>(args: Subset<T, Inv_Line_ProAggregateArgs>): Prisma.PrismaPromise<GetInv_Line_ProAggregateType<T>>

    /**
     * Group by Inv_Line_Pro.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Inv_Line_ProGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Inv_Line_ProGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Inv_Line_ProGroupByArgs['orderBy'] }
        : { orderBy?: Inv_Line_ProGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Inv_Line_ProGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInv_Line_ProGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inv_Line_Pro model
   */
  readonly fields: Inv_Line_ProFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inv_Line_Pro.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Inv_Line_ProClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Inv_Line_Pro model
   */ 
  interface Inv_Line_ProFieldRefs {
    readonly id: FieldRef<"Inv_Line_Pro", 'Int'>
    readonly productId: FieldRef<"Inv_Line_Pro", 'Int'>
    readonly invoiceId: FieldRef<"Inv_Line_Pro", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Inv_Line_Pro findUnique
   */
  export type Inv_Line_ProFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter, which Inv_Line_Pro to fetch.
     */
    where: Inv_Line_ProWhereUniqueInput
  }


  /**
   * Inv_Line_Pro findUniqueOrThrow
   */
  export type Inv_Line_ProFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter, which Inv_Line_Pro to fetch.
     */
    where: Inv_Line_ProWhereUniqueInput
  }


  /**
   * Inv_Line_Pro findFirst
   */
  export type Inv_Line_ProFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter, which Inv_Line_Pro to fetch.
     */
    where?: Inv_Line_ProWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inv_Line_Pros to fetch.
     */
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inv_Line_Pros.
     */
    cursor?: Inv_Line_ProWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inv_Line_Pros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inv_Line_Pros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inv_Line_Pros.
     */
    distinct?: Inv_Line_ProScalarFieldEnum | Inv_Line_ProScalarFieldEnum[]
  }


  /**
   * Inv_Line_Pro findFirstOrThrow
   */
  export type Inv_Line_ProFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter, which Inv_Line_Pro to fetch.
     */
    where?: Inv_Line_ProWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inv_Line_Pros to fetch.
     */
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inv_Line_Pros.
     */
    cursor?: Inv_Line_ProWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inv_Line_Pros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inv_Line_Pros.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inv_Line_Pros.
     */
    distinct?: Inv_Line_ProScalarFieldEnum | Inv_Line_ProScalarFieldEnum[]
  }


  /**
   * Inv_Line_Pro findMany
   */
  export type Inv_Line_ProFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter, which Inv_Line_Pros to fetch.
     */
    where?: Inv_Line_ProWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inv_Line_Pros to fetch.
     */
    orderBy?: Inv_Line_ProOrderByWithRelationInput | Inv_Line_ProOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inv_Line_Pros.
     */
    cursor?: Inv_Line_ProWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inv_Line_Pros from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inv_Line_Pros.
     */
    skip?: number
    distinct?: Inv_Line_ProScalarFieldEnum | Inv_Line_ProScalarFieldEnum[]
  }


  /**
   * Inv_Line_Pro create
   */
  export type Inv_Line_ProCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * The data needed to create a Inv_Line_Pro.
     */
    data: XOR<Inv_Line_ProCreateInput, Inv_Line_ProUncheckedCreateInput>
  }


  /**
   * Inv_Line_Pro createMany
   */
  export type Inv_Line_ProCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inv_Line_Pros.
     */
    data: Inv_Line_ProCreateManyInput | Inv_Line_ProCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Inv_Line_Pro update
   */
  export type Inv_Line_ProUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * The data needed to update a Inv_Line_Pro.
     */
    data: XOR<Inv_Line_ProUpdateInput, Inv_Line_ProUncheckedUpdateInput>
    /**
     * Choose, which Inv_Line_Pro to update.
     */
    where: Inv_Line_ProWhereUniqueInput
  }


  /**
   * Inv_Line_Pro updateMany
   */
  export type Inv_Line_ProUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inv_Line_Pros.
     */
    data: XOR<Inv_Line_ProUpdateManyMutationInput, Inv_Line_ProUncheckedUpdateManyInput>
    /**
     * Filter which Inv_Line_Pros to update
     */
    where?: Inv_Line_ProWhereInput
  }


  /**
   * Inv_Line_Pro upsert
   */
  export type Inv_Line_ProUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * The filter to search for the Inv_Line_Pro to update in case it exists.
     */
    where: Inv_Line_ProWhereUniqueInput
    /**
     * In case the Inv_Line_Pro found by the `where` argument doesn't exist, create a new Inv_Line_Pro with this data.
     */
    create: XOR<Inv_Line_ProCreateInput, Inv_Line_ProUncheckedCreateInput>
    /**
     * In case the Inv_Line_Pro was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Inv_Line_ProUpdateInput, Inv_Line_ProUncheckedUpdateInput>
  }


  /**
   * Inv_Line_Pro delete
   */
  export type Inv_Line_ProDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
    /**
     * Filter which Inv_Line_Pro to delete.
     */
    where: Inv_Line_ProWhereUniqueInput
  }


  /**
   * Inv_Line_Pro deleteMany
   */
  export type Inv_Line_ProDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inv_Line_Pros to delete
     */
    where?: Inv_Line_ProWhereInput
  }


  /**
   * Inv_Line_Pro without action
   */
  export type Inv_Line_ProDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inv_Line_Pro
     */
    select?: Inv_Line_ProSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Inv_Line_ProInclude<ExtArgs> | null
  }



  /**
   * Model Publication
   */

  export type AggregatePublication = {
    _count: PublicationCountAggregateOutputType | null
    _avg: PublicationAvgAggregateOutputType | null
    _sum: PublicationSumAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  export type PublicationAvgAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
  }

  export type PublicationSumAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
  }

  export type PublicationMinAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    name: string | null
    description: string | null
    image: Buffer | null
    date: Date | null
    status: boolean | null
  }

  export type PublicationMaxAggregateOutputType = {
    id: number | null
    customerId: number | null
    userId: number | null
    name: string | null
    description: string | null
    image: Buffer | null
    date: Date | null
    status: boolean | null
  }

  export type PublicationCountAggregateOutputType = {
    id: number
    customerId: number
    userId: number
    name: number
    description: number
    image: number
    date: number
    status: number
    _all: number
  }


  export type PublicationAvgAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
  }

  export type PublicationSumAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
  }

  export type PublicationMinAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    name?: true
    description?: true
    image?: true
    date?: true
    status?: true
  }

  export type PublicationMaxAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    name?: true
    description?: true
    image?: true
    date?: true
    status?: true
  }

  export type PublicationCountAggregateInputType = {
    id?: true
    customerId?: true
    userId?: true
    name?: true
    description?: true
    image?: true
    date?: true
    status?: true
    _all?: true
  }

  export type PublicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publication to aggregate.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Publications
    **/
    _count?: true | PublicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PublicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PublicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationMaxAggregateInputType
  }

  export type GetPublicationAggregateType<T extends PublicationAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication[P]>
      : GetScalarType<T[P], AggregatePublication[P]>
  }




  export type PublicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PublicationWhereInput
    orderBy?: PublicationOrderByWithAggregationInput | PublicationOrderByWithAggregationInput[]
    by: PublicationScalarFieldEnum[] | PublicationScalarFieldEnum
    having?: PublicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationCountAggregateInputType | true
    _avg?: PublicationAvgAggregateInputType
    _sum?: PublicationSumAggregateInputType
    _min?: PublicationMinAggregateInputType
    _max?: PublicationMaxAggregateInputType
  }

  export type PublicationGroupByOutputType = {
    id: number
    customerId: number | null
    userId: number | null
    name: string
    description: string | null
    image: Buffer | null
    date: Date
    status: boolean
    _count: PublicationCountAggregateOutputType | null
    _avg: PublicationAvgAggregateOutputType | null
    _sum: PublicationSumAggregateOutputType | null
    _min: PublicationMinAggregateOutputType | null
    _max: PublicationMaxAggregateOutputType | null
  }

  type GetPublicationGroupByPayload<T extends PublicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationGroupByOutputType[P]>
        }
      >
    >


  export type PublicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    date?: boolean
    status?: boolean
    customer?: boolean | Publication$customerArgs<ExtArgs>
    user?: boolean | Publication$userArgs<ExtArgs>
    reactios?: boolean | Publication$reactiosArgs<ExtArgs>
    comments?: boolean | Publication$commentsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication"]>

  export type PublicationSelectScalar = {
    id?: boolean
    customerId?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    image?: boolean
    date?: boolean
    status?: boolean
  }

  export type PublicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | Publication$customerArgs<ExtArgs>
    user?: boolean | Publication$userArgs<ExtArgs>
    reactios?: boolean | Publication$reactiosArgs<ExtArgs>
    comments?: boolean | Publication$commentsArgs<ExtArgs>
    _count?: boolean | PublicationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $PublicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Publication"
    objects: {
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      reactios: Prisma.$ReactPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerId: number | null
      userId: number | null
      name: string
      description: string | null
      image: Buffer | null
      date: Date
      status: boolean
    }, ExtArgs["result"]["publication"]>
    composites: {}
  }


  type PublicationGetPayload<S extends boolean | null | undefined | PublicationDefaultArgs> = $Result.GetResult<Prisma.$PublicationPayload, S>

  type PublicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PublicationFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: PublicationCountAggregateInputType | true
    }

  export interface PublicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Publication'], meta: { name: 'Publication' } }
    /**
     * Find zero or one Publication that matches the filter.
     * @param {PublicationFindUniqueArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PublicationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationFindUniqueArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Publication that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PublicationFindUniqueOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PublicationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Publication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PublicationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationFindFirstArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Publication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindFirstOrThrowArgs} args - Arguments to find a Publication
     * @example
     * // Get one Publication
     * const publication = await prisma.publication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PublicationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publication.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationWithIdOnly = await prisma.publication.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PublicationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Publication.
     * @param {PublicationCreateArgs} args - Arguments to create a Publication.
     * @example
     * // Create one Publication
     * const Publication = await prisma.publication.create({
     *   data: {
     *     // ... data to create a Publication
     *   }
     * })
     * 
    **/
    create<T extends PublicationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationCreateArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Publications.
     *     @param {PublicationCreateManyArgs} args - Arguments to create many Publications.
     *     @example
     *     // Create many Publications
     *     const publication = await prisma.publication.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PublicationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Publication.
     * @param {PublicationDeleteArgs} args - Arguments to delete one Publication.
     * @example
     * // Delete one Publication
     * const Publication = await prisma.publication.delete({
     *   where: {
     *     // ... filter to delete one Publication
     *   }
     * })
     * 
    **/
    delete<T extends PublicationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationDeleteArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Publication.
     * @param {PublicationUpdateArgs} args - Arguments to update one Publication.
     * @example
     * // Update one Publication
     * const publication = await prisma.publication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PublicationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationUpdateArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Publications.
     * @param {PublicationDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PublicationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PublicationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publication = await prisma.publication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PublicationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Publication.
     * @param {PublicationUpsertArgs} args - Arguments to update or create a Publication.
     * @example
     * // Update or create a Publication
     * const publication = await prisma.publication.upsert({
     *   create: {
     *     // ... data to create a Publication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication we want to update
     *   }
     * })
    **/
    upsert<T extends PublicationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PublicationUpsertArgs<ExtArgs>>
    ): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publication.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends PublicationCountArgs>(
      args?: Subset<T, PublicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationAggregateArgs>(args: Subset<T, PublicationAggregateArgs>): Prisma.PrismaPromise<GetPublicationAggregateType<T>>

    /**
     * Group by Publication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PublicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PublicationGroupByArgs['orderBy'] }
        : { orderBy?: PublicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PublicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Publication model
   */
  readonly fields: PublicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Publication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PublicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    customer<T extends Publication$customerArgs<ExtArgs> = {}>(args?: Subset<T, Publication$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    user<T extends Publication$userArgs<ExtArgs> = {}>(args?: Subset<T, Publication$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    reactios<T extends Publication$reactiosArgs<ExtArgs> = {}>(args?: Subset<T, Publication$reactiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findMany'> | Null>;

    comments<T extends Publication$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Publication$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Publication model
   */ 
  interface PublicationFieldRefs {
    readonly id: FieldRef<"Publication", 'Int'>
    readonly customerId: FieldRef<"Publication", 'Int'>
    readonly userId: FieldRef<"Publication", 'Int'>
    readonly name: FieldRef<"Publication", 'String'>
    readonly description: FieldRef<"Publication", 'String'>
    readonly image: FieldRef<"Publication", 'Bytes'>
    readonly date: FieldRef<"Publication", 'DateTime'>
    readonly status: FieldRef<"Publication", 'Boolean'>
  }
    

  // Custom InputTypes

  /**
   * Publication findUnique
   */
  export type PublicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }


  /**
   * Publication findUniqueOrThrow
   */
  export type PublicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where: PublicationWhereUniqueInput
  }


  /**
   * Publication findFirst
   */
  export type PublicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }


  /**
   * Publication findFirstOrThrow
   */
  export type PublicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publication to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Publications.
     */
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }


  /**
   * Publication findMany
   */
  export type PublicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter, which Publications to fetch.
     */
    where?: PublicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Publications to fetch.
     */
    orderBy?: PublicationOrderByWithRelationInput | PublicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Publications.
     */
    cursor?: PublicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Publications.
     */
    skip?: number
    distinct?: PublicationScalarFieldEnum | PublicationScalarFieldEnum[]
  }


  /**
   * Publication create
   */
  export type PublicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Publication.
     */
    data: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
  }


  /**
   * Publication createMany
   */
  export type PublicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Publications.
     */
    data: PublicationCreateManyInput | PublicationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Publication update
   */
  export type PublicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Publication.
     */
    data: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
    /**
     * Choose, which Publication to update.
     */
    where: PublicationWhereUniqueInput
  }


  /**
   * Publication updateMany
   */
  export type PublicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Publications.
     */
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyInput>
    /**
     * Filter which Publications to update
     */
    where?: PublicationWhereInput
  }


  /**
   * Publication upsert
   */
  export type PublicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Publication to update in case it exists.
     */
    where: PublicationWhereUniqueInput
    /**
     * In case the Publication found by the `where` argument doesn't exist, create a new Publication with this data.
     */
    create: XOR<PublicationCreateInput, PublicationUncheckedCreateInput>
    /**
     * In case the Publication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PublicationUpdateInput, PublicationUncheckedUpdateInput>
  }


  /**
   * Publication delete
   */
  export type PublicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
    /**
     * Filter which Publication to delete.
     */
    where: PublicationWhereUniqueInput
  }


  /**
   * Publication deleteMany
   */
  export type PublicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Publications to delete
     */
    where?: PublicationWhereInput
  }


  /**
   * Publication.customer
   */
  export type Publication$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }


  /**
   * Publication.user
   */
  export type Publication$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }


  /**
   * Publication.reactios
   */
  export type Publication$reactiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    where?: ReactWhereInput
    orderBy?: ReactOrderByWithRelationInput | ReactOrderByWithRelationInput[]
    cursor?: ReactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactScalarFieldEnum | ReactScalarFieldEnum[]
  }


  /**
   * Publication.comments
   */
  export type Publication$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Publication without action
   */
  export type PublicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Publication
     */
    select?: PublicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PublicationInclude<ExtArgs> | null
  }



  /**
   * Model React
   */

  export type AggregateReact = {
    _count: ReactCountAggregateOutputType | null
    _avg: ReactAvgAggregateOutputType | null
    _sum: ReactSumAggregateOutputType | null
    _min: ReactMinAggregateOutputType | null
    _max: ReactMaxAggregateOutputType | null
  }

  export type ReactAvgAggregateOutputType = {
    id: number | null
    publicationId: number | null
  }

  export type ReactSumAggregateOutputType = {
    id: number | null
    publicationId: number | null
  }

  export type ReactMinAggregateOutputType = {
    id: number | null
    publicationId: number | null
    name: string | null
  }

  export type ReactMaxAggregateOutputType = {
    id: number | null
    publicationId: number | null
    name: string | null
  }

  export type ReactCountAggregateOutputType = {
    id: number
    publicationId: number
    name: number
    _all: number
  }


  export type ReactAvgAggregateInputType = {
    id?: true
    publicationId?: true
  }

  export type ReactSumAggregateInputType = {
    id?: true
    publicationId?: true
  }

  export type ReactMinAggregateInputType = {
    id?: true
    publicationId?: true
    name?: true
  }

  export type ReactMaxAggregateInputType = {
    id?: true
    publicationId?: true
    name?: true
  }

  export type ReactCountAggregateInputType = {
    id?: true
    publicationId?: true
    name?: true
    _all?: true
  }

  export type ReactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which React to aggregate.
     */
    where?: ReactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacts to fetch.
     */
    orderBy?: ReactOrderByWithRelationInput | ReactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reacts
    **/
    _count?: true | ReactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactMaxAggregateInputType
  }

  export type GetReactAggregateType<T extends ReactAggregateArgs> = {
        [P in keyof T & keyof AggregateReact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReact[P]>
      : GetScalarType<T[P], AggregateReact[P]>
  }




  export type ReactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactWhereInput
    orderBy?: ReactOrderByWithAggregationInput | ReactOrderByWithAggregationInput[]
    by: ReactScalarFieldEnum[] | ReactScalarFieldEnum
    having?: ReactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactCountAggregateInputType | true
    _avg?: ReactAvgAggregateInputType
    _sum?: ReactSumAggregateInputType
    _min?: ReactMinAggregateInputType
    _max?: ReactMaxAggregateInputType
  }

  export type ReactGroupByOutputType = {
    id: number
    publicationId: number
    name: string
    _count: ReactCountAggregateOutputType | null
    _avg: ReactAvgAggregateOutputType | null
    _sum: ReactSumAggregateOutputType | null
    _min: ReactMinAggregateOutputType | null
    _max: ReactMaxAggregateOutputType | null
  }

  type GetReactGroupByPayload<T extends ReactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactGroupByOutputType[P]>
            : GetScalarType<T[P], ReactGroupByOutputType[P]>
        }
      >
    >


  export type ReactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicationId?: boolean
    name?: boolean
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["react"]>

  export type ReactSelectScalar = {
    id?: boolean
    publicationId?: boolean
    name?: boolean
  }

  export type ReactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
  }


  export type $ReactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "React"
    objects: {
      publication: Prisma.$PublicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicationId: number
      name: string
    }, ExtArgs["result"]["react"]>
    composites: {}
  }


  type ReactGetPayload<S extends boolean | null | undefined | ReactDefaultArgs> = $Result.GetResult<Prisma.$ReactPayload, S>

  type ReactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReactFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: ReactCountAggregateInputType | true
    }

  export interface ReactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['React'], meta: { name: 'React' } }
    /**
     * Find zero or one React that matches the filter.
     * @param {ReactFindUniqueArgs} args - Arguments to find a React
     * @example
     * // Get one React
     * const react = await prisma.react.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ReactFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ReactFindUniqueArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one React that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ReactFindUniqueOrThrowArgs} args - Arguments to find a React
     * @example
     * // Get one React
     * const react = await prisma.react.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ReactFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first React that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactFindFirstArgs} args - Arguments to find a React
     * @example
     * // Get one React
     * const react = await prisma.react.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ReactFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactFindFirstArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first React that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactFindFirstOrThrowArgs} args - Arguments to find a React
     * @example
     * // Get one React
     * const react = await prisma.react.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ReactFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Reacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reacts
     * const reacts = await prisma.react.findMany()
     * 
     * // Get first 10 Reacts
     * const reacts = await prisma.react.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactWithIdOnly = await prisma.react.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ReactFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a React.
     * @param {ReactCreateArgs} args - Arguments to create a React.
     * @example
     * // Create one React
     * const React = await prisma.react.create({
     *   data: {
     *     // ... data to create a React
     *   }
     * })
     * 
    **/
    create<T extends ReactCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ReactCreateArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Reacts.
     *     @param {ReactCreateManyArgs} args - Arguments to create many Reacts.
     *     @example
     *     // Create many Reacts
     *     const react = await prisma.react.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ReactCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a React.
     * @param {ReactDeleteArgs} args - Arguments to delete one React.
     * @example
     * // Delete one React
     * const React = await prisma.react.delete({
     *   where: {
     *     // ... filter to delete one React
     *   }
     * })
     * 
    **/
    delete<T extends ReactDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ReactDeleteArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one React.
     * @param {ReactUpdateArgs} args - Arguments to update one React.
     * @example
     * // Update one React
     * const react = await prisma.react.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ReactUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ReactUpdateArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Reacts.
     * @param {ReactDeleteManyArgs} args - Arguments to filter Reacts to delete.
     * @example
     * // Delete a few Reacts
     * const { count } = await prisma.react.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ReactDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ReactDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reacts
     * const react = await prisma.react.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ReactUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ReactUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one React.
     * @param {ReactUpsertArgs} args - Arguments to update or create a React.
     * @example
     * // Update or create a React
     * const react = await prisma.react.upsert({
     *   create: {
     *     // ... data to create a React
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the React we want to update
     *   }
     * })
    **/
    upsert<T extends ReactUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ReactUpsertArgs<ExtArgs>>
    ): Prisma__ReactClient<$Result.GetResult<Prisma.$ReactPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Reacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactCountArgs} args - Arguments to filter Reacts to count.
     * @example
     * // Count the number of Reacts
     * const count = await prisma.react.count({
     *   where: {
     *     // ... the filter for the Reacts we want to count
     *   }
     * })
    **/
    count<T extends ReactCountArgs>(
      args?: Subset<T, ReactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a React.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactAggregateArgs>(args: Subset<T, ReactAggregateArgs>): Prisma.PrismaPromise<GetReactAggregateType<T>>

    /**
     * Group by React.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactGroupByArgs['orderBy'] }
        : { orderBy?: ReactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the React model
   */
  readonly fields: ReactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for React.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    publication<T extends PublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationDefaultArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the React model
   */ 
  interface ReactFieldRefs {
    readonly id: FieldRef<"React", 'Int'>
    readonly publicationId: FieldRef<"React", 'Int'>
    readonly name: FieldRef<"React", 'String'>
  }
    

  // Custom InputTypes

  /**
   * React findUnique
   */
  export type ReactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter, which React to fetch.
     */
    where: ReactWhereUniqueInput
  }


  /**
   * React findUniqueOrThrow
   */
  export type ReactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter, which React to fetch.
     */
    where: ReactWhereUniqueInput
  }


  /**
   * React findFirst
   */
  export type ReactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter, which React to fetch.
     */
    where?: ReactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacts to fetch.
     */
    orderBy?: ReactOrderByWithRelationInput | ReactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reacts.
     */
    cursor?: ReactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reacts.
     */
    distinct?: ReactScalarFieldEnum | ReactScalarFieldEnum[]
  }


  /**
   * React findFirstOrThrow
   */
  export type ReactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter, which React to fetch.
     */
    where?: ReactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacts to fetch.
     */
    orderBy?: ReactOrderByWithRelationInput | ReactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reacts.
     */
    cursor?: ReactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reacts.
     */
    distinct?: ReactScalarFieldEnum | ReactScalarFieldEnum[]
  }


  /**
   * React findMany
   */
  export type ReactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter, which Reacts to fetch.
     */
    where?: ReactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reacts to fetch.
     */
    orderBy?: ReactOrderByWithRelationInput | ReactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reacts.
     */
    cursor?: ReactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reacts.
     */
    skip?: number
    distinct?: ReactScalarFieldEnum | ReactScalarFieldEnum[]
  }


  /**
   * React create
   */
  export type ReactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * The data needed to create a React.
     */
    data: XOR<ReactCreateInput, ReactUncheckedCreateInput>
  }


  /**
   * React createMany
   */
  export type ReactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reacts.
     */
    data: ReactCreateManyInput | ReactCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * React update
   */
  export type ReactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * The data needed to update a React.
     */
    data: XOR<ReactUpdateInput, ReactUncheckedUpdateInput>
    /**
     * Choose, which React to update.
     */
    where: ReactWhereUniqueInput
  }


  /**
   * React updateMany
   */
  export type ReactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reacts.
     */
    data: XOR<ReactUpdateManyMutationInput, ReactUncheckedUpdateManyInput>
    /**
     * Filter which Reacts to update
     */
    where?: ReactWhereInput
  }


  /**
   * React upsert
   */
  export type ReactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * The filter to search for the React to update in case it exists.
     */
    where: ReactWhereUniqueInput
    /**
     * In case the React found by the `where` argument doesn't exist, create a new React with this data.
     */
    create: XOR<ReactCreateInput, ReactUncheckedCreateInput>
    /**
     * In case the React was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactUpdateInput, ReactUncheckedUpdateInput>
  }


  /**
   * React delete
   */
  export type ReactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
    /**
     * Filter which React to delete.
     */
    where: ReactWhereUniqueInput
  }


  /**
   * React deleteMany
   */
  export type ReactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reacts to delete
     */
    where?: ReactWhereInput
  }


  /**
   * React without action
   */
  export type ReactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the React
     */
    select?: ReactSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ReactInclude<ExtArgs> | null
  }



  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    id: number | null
    publicationId: number | null
  }

  export type CommentSumAggregateOutputType = {
    id: number | null
    publicationId: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: number | null
    publicationId: number | null
    text: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: number | null
    publicationId: number | null
    text: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    publicationId: number
    text: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    id?: true
    publicationId?: true
  }

  export type CommentSumAggregateInputType = {
    id?: true
    publicationId?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    publicationId?: true
    text?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    publicationId?: true
    text?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    publicationId?: true
    text?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: number
    publicationId: number
    text: string
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publicationId?: boolean
    text?: boolean
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    publicationId?: boolean
    text?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication?: boolean | PublicationDefaultArgs<ExtArgs>
  }


  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      publication: Prisma.$PublicationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      publicationId: number
      text: string
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }


  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' > & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CommentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CommentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CommentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
    **/
    create<T extends CommentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentCreateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Comments.
     *     @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     *     @example
     *     // Create many Comments
     *     const comment = await prisma.comment.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CommentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
    **/
    delete<T extends CommentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CommentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CommentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CommentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
    **/
    upsert<T extends CommentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>
    ): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    publication<T extends PublicationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PublicationDefaultArgs<ExtArgs>>): Prisma__PublicationClient<$Result.GetResult<Prisma.$PublicationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'Int'>
    readonly publicationId: FieldRef<"Comment", 'Int'>
    readonly text: FieldRef<"Comment", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }


  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }


  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }


  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }


  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }


  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }


  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: CommentInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    lname: 'lname',
    phone: 'phone',
    idCard: 'idCard',
    semestre: 'semestre',
    status: 'status',
    alias: 'alias',
    biography: 'biography'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FollowerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    comunityId: 'comunityId',
    date: 'date',
    status: 'status'
  };

  export type FollowerScalarFieldEnum = (typeof FollowerScalarFieldEnum)[keyof typeof FollowerScalarFieldEnum]


  export const ComunityScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    date_start: 'date_start'
  };

  export type ComunityScalarFieldEnum = (typeof ComunityScalarFieldEnum)[keyof typeof ComunityScalarFieldEnum]


  export const ForoScalarFieldEnum: {
    id: 'id',
    subject: 'subject',
    description: 'description',
    date_publication: 'date_publication',
    date_update: 'date_update',
    comunityId: 'comunityId'
  };

  export type ForoScalarFieldEnum = (typeof ForoScalarFieldEnum)[keyof typeof ForoScalarFieldEnum]


  export const AnswerScalarFieldEnum: {
    id: 'id',
    message: 'message',
    foroId: 'foroId'
  };

  export type AnswerScalarFieldEnum = (typeof AnswerScalarFieldEnum)[keyof typeof AnswerScalarFieldEnum]


  export const ResponseScalarFieldEnum: {
    id: 'id',
    message: 'message',
    foroId: 'foroId',
    answerId: 'answerId'
  };

  export type ResponseScalarFieldEnum = (typeof ResponseScalarFieldEnum)[keyof typeof ResponseScalarFieldEnum]


  export const RolScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type RolScalarFieldEnum = (typeof RolScalarFieldEnum)[keyof typeof RolScalarFieldEnum]


  export const LinkScalarFieldEnum: {
    id: 'id',
    rolId: 'rolId',
    name: 'name',
    Link: 'Link'
  };

  export type LinkScalarFieldEnum = (typeof LinkScalarFieldEnum)[keyof typeof LinkScalarFieldEnum]


  export const User_line_linkScalarFieldEnum: {
    id: 'id',
    linkId: 'linkId',
    userId: 'userId'
  };

  export type User_line_linkScalarFieldEnum = (typeof User_line_linkScalarFieldEnum)[keyof typeof User_line_linkScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    DATE_START: 'DATE_START',
    DATE_END: 'DATE_END'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    categoryId: 'categoryId',
    serviceid: 'serviceid',
    name: 'name',
    description: 'description',
    price: 'price',
    date_create: 'date_create',
    status: 'status'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    lname: 'lname',
    phone: 'phone',
    idCard: 'idCard',
    Company: 'Company',
    city: 'city',
    job: 'job'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    date: 'date'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const Inv_Line_ProScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    invoiceId: 'invoiceId'
  };

  export type Inv_Line_ProScalarFieldEnum = (typeof Inv_Line_ProScalarFieldEnum)[keyof typeof Inv_Line_ProScalarFieldEnum]


  export const PublicationScalarFieldEnum: {
    id: 'id',
    customerId: 'customerId',
    userId: 'userId',
    name: 'name',
    description: 'description',
    image: 'image',
    date: 'date',
    status: 'status'
  };

  export type PublicationScalarFieldEnum = (typeof PublicationScalarFieldEnum)[keyof typeof PublicationScalarFieldEnum]


  export const ReactScalarFieldEnum: {
    id: 'id',
    publicationId: 'publicationId',
    name: 'name'
  };

  export type ReactScalarFieldEnum = (typeof ReactScalarFieldEnum)[keyof typeof ReactScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    publicationId: 'publicationId',
    text: 'text'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    lname?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    idCard?: StringFilter<"User"> | string
    semestre?: IntFilter<"User"> | number
    status?: BoolFilter<"User"> | boolean
    alias?: StringNullableFilter<"User"> | string | null
    biography?: StringFilter<"User"> | string
    communities?: ComunityListRelationFilter
    followers?: FollowerListRelationFilter
    user_line_link?: User_line_linkListRelationFilter
    products?: ProductListRelationFilter
    publications?: PublicationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    semestre?: SortOrder
    status?: SortOrder
    alias?: SortOrderInput | SortOrder
    biography?: SortOrder
    communities?: ComunityOrderByRelationAggregateInput
    followers?: FollowerOrderByRelationAggregateInput
    user_line_link?: user_line_linkOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    publications?: PublicationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    lname?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    idCard?: StringFilter<"User"> | string
    semestre?: IntFilter<"User"> | number
    status?: BoolFilter<"User"> | boolean
    alias?: StringNullableFilter<"User"> | string | null
    biography?: StringFilter<"User"> | string
    communities?: ComunityListRelationFilter
    followers?: FollowerListRelationFilter
    user_line_link?: User_line_linkListRelationFilter
    products?: ProductListRelationFilter
    publications?: PublicationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrderInput | SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    semestre?: SortOrder
    status?: SortOrder
    alias?: SortOrderInput | SortOrder
    biography?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    lname?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    idCard?: StringWithAggregatesFilter<"User"> | string
    semestre?: IntWithAggregatesFilter<"User"> | number
    status?: BoolWithAggregatesFilter<"User"> | boolean
    alias?: StringNullableWithAggregatesFilter<"User"> | string | null
    biography?: StringWithAggregatesFilter<"User"> | string
  }

  export type FollowerWhereInput = {
    AND?: FollowerWhereInput | FollowerWhereInput[]
    OR?: FollowerWhereInput[]
    NOT?: FollowerWhereInput | FollowerWhereInput[]
    id?: IntFilter<"Follower"> | number
    userId?: IntFilter<"Follower"> | number
    comunityId?: IntNullableFilter<"Follower"> | number | null
    date?: DateTimeFilter<"Follower"> | Date | string
    status?: BoolFilter<"Follower"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    community?: XOR<ComunityNullableRelationFilter, ComunityWhereInput> | null
  }

  export type FollowerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    user?: UserOrderByWithRelationInput
    community?: ComunityOrderByWithRelationInput
  }

  export type FollowerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FollowerWhereInput | FollowerWhereInput[]
    OR?: FollowerWhereInput[]
    NOT?: FollowerWhereInput | FollowerWhereInput[]
    userId?: IntFilter<"Follower"> | number
    comunityId?: IntNullableFilter<"Follower"> | number | null
    date?: DateTimeFilter<"Follower"> | Date | string
    status?: BoolFilter<"Follower"> | boolean
    user?: XOR<UserRelationFilter, UserWhereInput>
    community?: XOR<ComunityNullableRelationFilter, ComunityWhereInput> | null
  }, "id">

  export type FollowerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: FollowerCountOrderByAggregateInput
    _avg?: FollowerAvgOrderByAggregateInput
    _max?: FollowerMaxOrderByAggregateInput
    _min?: FollowerMinOrderByAggregateInput
    _sum?: FollowerSumOrderByAggregateInput
  }

  export type FollowerScalarWhereWithAggregatesInput = {
    AND?: FollowerScalarWhereWithAggregatesInput | FollowerScalarWhereWithAggregatesInput[]
    OR?: FollowerScalarWhereWithAggregatesInput[]
    NOT?: FollowerScalarWhereWithAggregatesInput | FollowerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Follower"> | number
    userId?: IntWithAggregatesFilter<"Follower"> | number
    comunityId?: IntNullableWithAggregatesFilter<"Follower"> | number | null
    date?: DateTimeWithAggregatesFilter<"Follower"> | Date | string
    status?: BoolWithAggregatesFilter<"Follower"> | boolean
  }

  export type ComunityWhereInput = {
    AND?: ComunityWhereInput | ComunityWhereInput[]
    OR?: ComunityWhereInput[]
    NOT?: ComunityWhereInput | ComunityWhereInput[]
    id?: IntFilter<"Comunity"> | number
    userId?: IntFilter<"Comunity"> | number
    name?: StringFilter<"Comunity"> | string
    date_start?: DateTimeFilter<"Comunity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    followers?: FollowerListRelationFilter
    foros?: ForoListRelationFilter
  }

  export type ComunityOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date_start?: SortOrder
    user?: UserOrderByWithRelationInput
    followers?: FollowerOrderByRelationAggregateInput
    foros?: ForoOrderByRelationAggregateInput
  }

  export type ComunityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComunityWhereInput | ComunityWhereInput[]
    OR?: ComunityWhereInput[]
    NOT?: ComunityWhereInput | ComunityWhereInput[]
    userId?: IntFilter<"Comunity"> | number
    name?: StringFilter<"Comunity"> | string
    date_start?: DateTimeFilter<"Comunity"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    followers?: FollowerListRelationFilter
    foros?: ForoListRelationFilter
  }, "id">

  export type ComunityOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date_start?: SortOrder
    _count?: ComunityCountOrderByAggregateInput
    _avg?: ComunityAvgOrderByAggregateInput
    _max?: ComunityMaxOrderByAggregateInput
    _min?: ComunityMinOrderByAggregateInput
    _sum?: ComunitySumOrderByAggregateInput
  }

  export type ComunityScalarWhereWithAggregatesInput = {
    AND?: ComunityScalarWhereWithAggregatesInput | ComunityScalarWhereWithAggregatesInput[]
    OR?: ComunityScalarWhereWithAggregatesInput[]
    NOT?: ComunityScalarWhereWithAggregatesInput | ComunityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comunity"> | number
    userId?: IntWithAggregatesFilter<"Comunity"> | number
    name?: StringWithAggregatesFilter<"Comunity"> | string
    date_start?: DateTimeWithAggregatesFilter<"Comunity"> | Date | string
  }

  export type ForoWhereInput = {
    AND?: ForoWhereInput | ForoWhereInput[]
    OR?: ForoWhereInput[]
    NOT?: ForoWhereInput | ForoWhereInput[]
    id?: IntFilter<"Foro"> | number
    subject?: StringNullableFilter<"Foro"> | string | null
    description?: StringFilter<"Foro"> | string
    date_publication?: DateTimeNullableFilter<"Foro"> | Date | string | null
    date_update?: DateTimeNullableFilter<"Foro"> | Date | string | null
    comunityId?: IntFilter<"Foro"> | number
    answers?: XOR<AnswerNullableRelationFilter, AnswerWhereInput> | null
    responses?: XOR<ResponseNullableRelationFilter, ResponseWhereInput> | null
    comunity?: XOR<ComunityRelationFilter, ComunityWhereInput>
  }

  export type ForoOrderByWithRelationInput = {
    id?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrder
    date_publication?: SortOrderInput | SortOrder
    date_update?: SortOrderInput | SortOrder
    comunityId?: SortOrder
    answers?: AnswerOrderByWithRelationInput
    responses?: ResponseOrderByWithRelationInput
    comunity?: ComunityOrderByWithRelationInput
  }

  export type ForoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ForoWhereInput | ForoWhereInput[]
    OR?: ForoWhereInput[]
    NOT?: ForoWhereInput | ForoWhereInput[]
    subject?: StringNullableFilter<"Foro"> | string | null
    description?: StringFilter<"Foro"> | string
    date_publication?: DateTimeNullableFilter<"Foro"> | Date | string | null
    date_update?: DateTimeNullableFilter<"Foro"> | Date | string | null
    comunityId?: IntFilter<"Foro"> | number
    answers?: XOR<AnswerNullableRelationFilter, AnswerWhereInput> | null
    responses?: XOR<ResponseNullableRelationFilter, ResponseWhereInput> | null
    comunity?: XOR<ComunityRelationFilter, ComunityWhereInput>
  }, "id">

  export type ForoOrderByWithAggregationInput = {
    id?: SortOrder
    subject?: SortOrderInput | SortOrder
    description?: SortOrder
    date_publication?: SortOrderInput | SortOrder
    date_update?: SortOrderInput | SortOrder
    comunityId?: SortOrder
    _count?: ForoCountOrderByAggregateInput
    _avg?: ForoAvgOrderByAggregateInput
    _max?: ForoMaxOrderByAggregateInput
    _min?: ForoMinOrderByAggregateInput
    _sum?: ForoSumOrderByAggregateInput
  }

  export type ForoScalarWhereWithAggregatesInput = {
    AND?: ForoScalarWhereWithAggregatesInput | ForoScalarWhereWithAggregatesInput[]
    OR?: ForoScalarWhereWithAggregatesInput[]
    NOT?: ForoScalarWhereWithAggregatesInput | ForoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Foro"> | number
    subject?: StringNullableWithAggregatesFilter<"Foro"> | string | null
    description?: StringWithAggregatesFilter<"Foro"> | string
    date_publication?: DateTimeNullableWithAggregatesFilter<"Foro"> | Date | string | null
    date_update?: DateTimeNullableWithAggregatesFilter<"Foro"> | Date | string | null
    comunityId?: IntWithAggregatesFilter<"Foro"> | number
  }

  export type AnswerWhereInput = {
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    id?: IntFilter<"Answer"> | number
    message?: StringNullableFilter<"Answer"> | string | null
    foroId?: IntFilter<"Answer"> | number
    foro?: XOR<ForoRelationFilter, ForoWhereInput>
    responses?: ResponseListRelationFilter
  }

  export type AnswerOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    foroId?: SortOrder
    foro?: ForoOrderByWithRelationInput
    responses?: ResponseOrderByRelationAggregateInput
  }

  export type AnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    foroId?: number
    AND?: AnswerWhereInput | AnswerWhereInput[]
    OR?: AnswerWhereInput[]
    NOT?: AnswerWhereInput | AnswerWhereInput[]
    message?: StringNullableFilter<"Answer"> | string | null
    foro?: XOR<ForoRelationFilter, ForoWhereInput>
    responses?: ResponseListRelationFilter
  }, "id" | "foroId">

  export type AnswerOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    foroId?: SortOrder
    _count?: AnswerCountOrderByAggregateInput
    _avg?: AnswerAvgOrderByAggregateInput
    _max?: AnswerMaxOrderByAggregateInput
    _min?: AnswerMinOrderByAggregateInput
    _sum?: AnswerSumOrderByAggregateInput
  }

  export type AnswerScalarWhereWithAggregatesInput = {
    AND?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    OR?: AnswerScalarWhereWithAggregatesInput[]
    NOT?: AnswerScalarWhereWithAggregatesInput | AnswerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Answer"> | number
    message?: StringNullableWithAggregatesFilter<"Answer"> | string | null
    foroId?: IntWithAggregatesFilter<"Answer"> | number
  }

  export type ResponseWhereInput = {
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    id?: IntFilter<"Response"> | number
    message?: StringNullableFilter<"Response"> | string | null
    foroId?: IntFilter<"Response"> | number
    answerId?: IntFilter<"Response"> | number
    foro?: XOR<ForoRelationFilter, ForoWhereInput>
    answer?: XOR<AnswerRelationFilter, AnswerWhereInput>
  }

  export type ResponseOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
    foro?: ForoOrderByWithRelationInput
    answer?: AnswerOrderByWithRelationInput
  }

  export type ResponseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    foroId?: number
    AND?: ResponseWhereInput | ResponseWhereInput[]
    OR?: ResponseWhereInput[]
    NOT?: ResponseWhereInput | ResponseWhereInput[]
    message?: StringNullableFilter<"Response"> | string | null
    answerId?: IntFilter<"Response"> | number
    foro?: XOR<ForoRelationFilter, ForoWhereInput>
    answer?: XOR<AnswerRelationFilter, AnswerWhereInput>
  }, "id" | "foroId">

  export type ResponseOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrderInput | SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
    _count?: ResponseCountOrderByAggregateInput
    _avg?: ResponseAvgOrderByAggregateInput
    _max?: ResponseMaxOrderByAggregateInput
    _min?: ResponseMinOrderByAggregateInput
    _sum?: ResponseSumOrderByAggregateInput
  }

  export type ResponseScalarWhereWithAggregatesInput = {
    AND?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    OR?: ResponseScalarWhereWithAggregatesInput[]
    NOT?: ResponseScalarWhereWithAggregatesInput | ResponseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Response"> | number
    message?: StringNullableWithAggregatesFilter<"Response"> | string | null
    foroId?: IntWithAggregatesFilter<"Response"> | number
    answerId?: IntWithAggregatesFilter<"Response"> | number
  }

  export type RolWhereInput = {
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    id?: IntFilter<"Rol"> | number
    name?: StringFilter<"Rol"> | string
    links?: LinkListRelationFilter
  }

  export type RolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    links?: LinkOrderByRelationAggregateInput
  }

  export type RolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RolWhereInput | RolWhereInput[]
    OR?: RolWhereInput[]
    NOT?: RolWhereInput | RolWhereInput[]
    name?: StringFilter<"Rol"> | string
    links?: LinkListRelationFilter
  }, "id">

  export type RolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: RolCountOrderByAggregateInput
    _avg?: RolAvgOrderByAggregateInput
    _max?: RolMaxOrderByAggregateInput
    _min?: RolMinOrderByAggregateInput
    _sum?: RolSumOrderByAggregateInput
  }

  export type RolScalarWhereWithAggregatesInput = {
    AND?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    OR?: RolScalarWhereWithAggregatesInput[]
    NOT?: RolScalarWhereWithAggregatesInput | RolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Rol"> | number
    name?: StringWithAggregatesFilter<"Rol"> | string
  }

  export type LinkWhereInput = {
    AND?: LinkWhereInput | LinkWhereInput[]
    OR?: LinkWhereInput[]
    NOT?: LinkWhereInput | LinkWhereInput[]
    id?: IntFilter<"Link"> | number
    rolId?: IntFilter<"Link"> | number
    name?: StringFilter<"Link"> | string
    Link?: StringFilter<"Link"> | string
    rol?: XOR<RolRelationFilter, RolWhereInput>
    userLineLink?: User_line_linkListRelationFilter
  }

  export type LinkOrderByWithRelationInput = {
    id?: SortOrder
    rolId?: SortOrder
    name?: SortOrder
    Link?: SortOrder
    rol?: RolOrderByWithRelationInput
    userLineLink?: user_line_linkOrderByRelationAggregateInput
  }

  export type LinkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LinkWhereInput | LinkWhereInput[]
    OR?: LinkWhereInput[]
    NOT?: LinkWhereInput | LinkWhereInput[]
    rolId?: IntFilter<"Link"> | number
    name?: StringFilter<"Link"> | string
    Link?: StringFilter<"Link"> | string
    rol?: XOR<RolRelationFilter, RolWhereInput>
    userLineLink?: User_line_linkListRelationFilter
  }, "id">

  export type LinkOrderByWithAggregationInput = {
    id?: SortOrder
    rolId?: SortOrder
    name?: SortOrder
    Link?: SortOrder
    _count?: LinkCountOrderByAggregateInput
    _avg?: LinkAvgOrderByAggregateInput
    _max?: LinkMaxOrderByAggregateInput
    _min?: LinkMinOrderByAggregateInput
    _sum?: LinkSumOrderByAggregateInput
  }

  export type LinkScalarWhereWithAggregatesInput = {
    AND?: LinkScalarWhereWithAggregatesInput | LinkScalarWhereWithAggregatesInput[]
    OR?: LinkScalarWhereWithAggregatesInput[]
    NOT?: LinkScalarWhereWithAggregatesInput | LinkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Link"> | number
    rolId?: IntWithAggregatesFilter<"Link"> | number
    name?: StringWithAggregatesFilter<"Link"> | string
    Link?: StringWithAggregatesFilter<"Link"> | string
  }

  export type user_line_linkWhereInput = {
    AND?: user_line_linkWhereInput | user_line_linkWhereInput[]
    OR?: user_line_linkWhereInput[]
    NOT?: user_line_linkWhereInput | user_line_linkWhereInput[]
    id?: IntFilter<"user_line_link"> | number
    linkId?: IntFilter<"user_line_link"> | number
    userId?: IntFilter<"user_line_link"> | number
    link?: XOR<LinkRelationFilter, LinkWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type user_line_linkOrderByWithRelationInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
    link?: LinkOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type user_line_linkWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: user_line_linkWhereInput | user_line_linkWhereInput[]
    OR?: user_line_linkWhereInput[]
    NOT?: user_line_linkWhereInput | user_line_linkWhereInput[]
    linkId?: IntFilter<"user_line_link"> | number
    userId?: IntFilter<"user_line_link"> | number
    link?: XOR<LinkRelationFilter, LinkWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type user_line_linkOrderByWithAggregationInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
    _count?: user_line_linkCountOrderByAggregateInput
    _avg?: user_line_linkAvgOrderByAggregateInput
    _max?: user_line_linkMaxOrderByAggregateInput
    _min?: user_line_linkMinOrderByAggregateInput
    _sum?: user_line_linkSumOrderByAggregateInput
  }

  export type user_line_linkScalarWhereWithAggregatesInput = {
    AND?: user_line_linkScalarWhereWithAggregatesInput | user_line_linkScalarWhereWithAggregatesInput[]
    OR?: user_line_linkScalarWhereWithAggregatesInput[]
    NOT?: user_line_linkScalarWhereWithAggregatesInput | user_line_linkScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_line_link"> | number
    linkId?: IntWithAggregatesFilter<"user_line_link"> | number
    userId?: IntWithAggregatesFilter<"user_line_link"> | number
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    description?: StringNullableFilter<"Category"> | string | null
    products?: ProductListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    description?: StringNullableWithAggregatesFilter<"Category"> | string | null
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    DATE_START?: DateTimeNullableFilter<"Service"> | Date | string | null
    DATE_END?: DateTimeNullableFilter<"Service"> | Date | string | null
    products?: ProductListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    DATE_START?: SortOrderInput | SortOrder
    DATE_END?: SortOrderInput | SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    name?: StringFilter<"Service"> | string
    DATE_START?: DateTimeNullableFilter<"Service"> | Date | string | null
    DATE_END?: DateTimeNullableFilter<"Service"> | Date | string | null
    products?: ProductListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    DATE_START?: SortOrderInput | SortOrder
    DATE_END?: SortOrderInput | SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    DATE_START?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
    DATE_END?: DateTimeNullableWithAggregatesFilter<"Service"> | Date | string | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    userId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    serviceid?: IntNullableFilter<"Product"> | number | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: StringNullableFilter<"Product"> | string | null
    date_create?: StringNullableFilter<"Product"> | string | null
    status?: BoolNullableFilter<"Product"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    inv_line_pros?: Inv_Line_ProListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    serviceid?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    category?: CategoryOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    inv_line_pros?: Inv_Line_ProOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    userId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    serviceid?: IntNullableFilter<"Product"> | number | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: StringNullableFilter<"Product"> | string | null
    date_create?: StringNullableFilter<"Product"> | string | null
    status?: BoolNullableFilter<"Product"> | boolean | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    category?: XOR<CategoryNullableRelationFilter, CategoryWhereInput> | null
    service?: XOR<ServiceNullableRelationFilter, ServiceWhereInput> | null
    inv_line_pros?: Inv_Line_ProListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    serviceid?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    date_create?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    userId?: IntWithAggregatesFilter<"Product"> | number
    categoryId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    serviceid?: IntNullableWithAggregatesFilter<"Product"> | number | null
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: StringNullableWithAggregatesFilter<"Product"> | string | null
    date_create?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: BoolNullableWithAggregatesFilter<"Product"> | boolean | null
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: IntFilter<"Customer"> | number
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    lname?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    idCard?: StringFilter<"Customer"> | string
    Company?: StringFilter<"Customer"> | string
    city?: StringNullableFilter<"Customer"> | string | null
    job?: StringFilter<"Customer"> | string
    invices?: InvoiceListRelationFilter
    publications?: PublicationListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    Company?: SortOrder
    city?: SortOrderInput | SortOrder
    job?: SortOrder
    invices?: InvoiceOrderByRelationAggregateInput
    publications?: PublicationOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    email?: StringFilter<"Customer"> | string
    password?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    lname?: StringFilter<"Customer"> | string
    phone?: StringFilter<"Customer"> | string
    idCard?: StringFilter<"Customer"> | string
    Company?: StringFilter<"Customer"> | string
    city?: StringNullableFilter<"Customer"> | string | null
    job?: StringFilter<"Customer"> | string
    invices?: InvoiceListRelationFilter
    publications?: PublicationListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    Company?: SortOrder
    city?: SortOrderInput | SortOrder
    job?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Customer"> | number
    email?: StringWithAggregatesFilter<"Customer"> | string
    password?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    lname?: StringWithAggregatesFilter<"Customer"> | string
    phone?: StringWithAggregatesFilter<"Customer"> | string
    idCard?: StringWithAggregatesFilter<"Customer"> | string
    Company?: StringWithAggregatesFilter<"Customer"> | string
    city?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    job?: StringWithAggregatesFilter<"Customer"> | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: IntFilter<"Invoice"> | number
    customerId?: IntFilter<"Invoice"> | number
    date?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    inv_line_pros?: Inv_Line_ProListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    inv_line_pros?: Inv_Line_ProOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    customerId?: IntFilter<"Invoice"> | number
    date?: DateTimeFilter<"Invoice"> | Date | string
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    inv_line_pros?: Inv_Line_ProListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Invoice"> | number
    customerId?: IntWithAggregatesFilter<"Invoice"> | number
    date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type Inv_Line_ProWhereInput = {
    AND?: Inv_Line_ProWhereInput | Inv_Line_ProWhereInput[]
    OR?: Inv_Line_ProWhereInput[]
    NOT?: Inv_Line_ProWhereInput | Inv_Line_ProWhereInput[]
    id?: IntFilter<"Inv_Line_Pro"> | number
    productId?: IntFilter<"Inv_Line_Pro"> | number
    invoiceId?: IntFilter<"Inv_Line_Pro"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type Inv_Line_ProOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
    product?: ProductOrderByWithRelationInput
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type Inv_Line_ProWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: Inv_Line_ProWhereInput | Inv_Line_ProWhereInput[]
    OR?: Inv_Line_ProWhereInput[]
    NOT?: Inv_Line_ProWhereInput | Inv_Line_ProWhereInput[]
    productId?: IntFilter<"Inv_Line_Pro"> | number
    invoiceId?: IntFilter<"Inv_Line_Pro"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type Inv_Line_ProOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
    _count?: Inv_Line_ProCountOrderByAggregateInput
    _avg?: Inv_Line_ProAvgOrderByAggregateInput
    _max?: Inv_Line_ProMaxOrderByAggregateInput
    _min?: Inv_Line_ProMinOrderByAggregateInput
    _sum?: Inv_Line_ProSumOrderByAggregateInput
  }

  export type Inv_Line_ProScalarWhereWithAggregatesInput = {
    AND?: Inv_Line_ProScalarWhereWithAggregatesInput | Inv_Line_ProScalarWhereWithAggregatesInput[]
    OR?: Inv_Line_ProScalarWhereWithAggregatesInput[]
    NOT?: Inv_Line_ProScalarWhereWithAggregatesInput | Inv_Line_ProScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Inv_Line_Pro"> | number
    productId?: IntWithAggregatesFilter<"Inv_Line_Pro"> | number
    invoiceId?: IntWithAggregatesFilter<"Inv_Line_Pro"> | number
  }

  export type PublicationWhereInput = {
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    id?: IntFilter<"Publication"> | number
    customerId?: IntNullableFilter<"Publication"> | number | null
    userId?: IntNullableFilter<"Publication"> | number | null
    name?: StringFilter<"Publication"> | string
    description?: StringNullableFilter<"Publication"> | string | null
    image?: BytesNullableFilter<"Publication"> | Buffer | null
    date?: DateTimeFilter<"Publication"> | Date | string
    status?: BoolFilter<"Publication"> | boolean
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reactios?: ReactListRelationFilter
    comments?: CommentListRelationFilter
  }

  export type PublicationOrderByWithRelationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    customer?: CustomerOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    reactios?: ReactOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
  }

  export type PublicationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PublicationWhereInput | PublicationWhereInput[]
    OR?: PublicationWhereInput[]
    NOT?: PublicationWhereInput | PublicationWhereInput[]
    customerId?: IntNullableFilter<"Publication"> | number | null
    userId?: IntNullableFilter<"Publication"> | number | null
    name?: StringFilter<"Publication"> | string
    description?: StringNullableFilter<"Publication"> | string | null
    image?: BytesNullableFilter<"Publication"> | Buffer | null
    date?: DateTimeFilter<"Publication"> | Date | string
    status?: BoolFilter<"Publication"> | boolean
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    reactios?: ReactListRelationFilter
    comments?: CommentListRelationFilter
  }, "id">

  export type PublicationOrderByWithAggregationInput = {
    id?: SortOrder
    customerId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    _count?: PublicationCountOrderByAggregateInput
    _avg?: PublicationAvgOrderByAggregateInput
    _max?: PublicationMaxOrderByAggregateInput
    _min?: PublicationMinOrderByAggregateInput
    _sum?: PublicationSumOrderByAggregateInput
  }

  export type PublicationScalarWhereWithAggregatesInput = {
    AND?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    OR?: PublicationScalarWhereWithAggregatesInput[]
    NOT?: PublicationScalarWhereWithAggregatesInput | PublicationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Publication"> | number
    customerId?: IntNullableWithAggregatesFilter<"Publication"> | number | null
    userId?: IntNullableWithAggregatesFilter<"Publication"> | number | null
    name?: StringWithAggregatesFilter<"Publication"> | string
    description?: StringNullableWithAggregatesFilter<"Publication"> | string | null
    image?: BytesNullableWithAggregatesFilter<"Publication"> | Buffer | null
    date?: DateTimeWithAggregatesFilter<"Publication"> | Date | string
    status?: BoolWithAggregatesFilter<"Publication"> | boolean
  }

  export type ReactWhereInput = {
    AND?: ReactWhereInput | ReactWhereInput[]
    OR?: ReactWhereInput[]
    NOT?: ReactWhereInput | ReactWhereInput[]
    id?: IntFilter<"React"> | number
    publicationId?: IntFilter<"React"> | number
    name?: StringFilter<"React"> | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
  }

  export type ReactOrderByWithRelationInput = {
    id?: SortOrder
    publicationId?: SortOrder
    name?: SortOrder
    publication?: PublicationOrderByWithRelationInput
  }

  export type ReactWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReactWhereInput | ReactWhereInput[]
    OR?: ReactWhereInput[]
    NOT?: ReactWhereInput | ReactWhereInput[]
    publicationId?: IntFilter<"React"> | number
    name?: StringFilter<"React"> | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
  }, "id">

  export type ReactOrderByWithAggregationInput = {
    id?: SortOrder
    publicationId?: SortOrder
    name?: SortOrder
    _count?: ReactCountOrderByAggregateInput
    _avg?: ReactAvgOrderByAggregateInput
    _max?: ReactMaxOrderByAggregateInput
    _min?: ReactMinOrderByAggregateInput
    _sum?: ReactSumOrderByAggregateInput
  }

  export type ReactScalarWhereWithAggregatesInput = {
    AND?: ReactScalarWhereWithAggregatesInput | ReactScalarWhereWithAggregatesInput[]
    OR?: ReactScalarWhereWithAggregatesInput[]
    NOT?: ReactScalarWhereWithAggregatesInput | ReactScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"React"> | number
    publicationId?: IntWithAggregatesFilter<"React"> | number
    name?: StringWithAggregatesFilter<"React"> | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: IntFilter<"Comment"> | number
    publicationId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    publicationId?: SortOrder
    text?: SortOrder
    publication?: PublicationOrderByWithRelationInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    publicationId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
    publication?: XOR<PublicationRelationFilter, PublicationWhereInput>
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    publicationId?: SortOrder
    text?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Comment"> | number
    publicationId?: IntWithAggregatesFilter<"Comment"> | number
    text?: StringWithAggregatesFilter<"Comment"> | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityCreateNestedManyWithoutUserInput
    followers?: FollowerCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowerUncheckedCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUpdateManyWithoutUserNestedInput
    followers?: FollowerUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowerUncheckedUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
  }

  export type FollowerCreateInput = {
    date: Date | string
    status: boolean
    user: UserCreateNestedOneWithoutFollowersInput
    community?: ComunityCreateNestedOneWithoutFollowersInput
  }

  export type FollowerUncheckedCreateInput = {
    id?: number
    userId: number
    comunityId?: number | null
    date: Date | string
    status: boolean
  }

  export type FollowerUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFollowersNestedInput
    community?: ComunityUpdateOneWithoutFollowersNestedInput
  }

  export type FollowerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    comunityId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowerCreateManyInput = {
    id?: number
    userId: number
    comunityId?: number | null
    date: Date | string
    status: boolean
  }

  export type FollowerUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    comunityId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ComunityCreateInput = {
    name: string
    date_start: Date | string
    user: UserCreateNestedOneWithoutCommunitiesInput
    followers?: FollowerCreateNestedManyWithoutCommunityInput
    foros?: ForoCreateNestedManyWithoutComunityInput
  }

  export type ComunityUncheckedCreateInput = {
    id?: number
    userId: number
    name: string
    date_start: Date | string
    followers?: FollowerUncheckedCreateNestedManyWithoutCommunityInput
    foros?: ForoUncheckedCreateNestedManyWithoutComunityInput
  }

  export type ComunityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunitiesNestedInput
    followers?: FollowerUpdateManyWithoutCommunityNestedInput
    foros?: ForoUpdateManyWithoutComunityNestedInput
  }

  export type ComunityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: FollowerUncheckedUpdateManyWithoutCommunityNestedInput
    foros?: ForoUncheckedUpdateManyWithoutComunityNestedInput
  }

  export type ComunityCreateManyInput = {
    id?: number
    userId: number
    name: string
    date_start: Date | string
  }

  export type ComunityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComunityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForoCreateInput = {
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    answers?: AnswerCreateNestedOneWithoutForoInput
    responses?: ResponseCreateNestedOneWithoutForoInput
    comunity: ComunityCreateNestedOneWithoutForosInput
  }

  export type ForoUncheckedCreateInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    comunityId: number
    answers?: AnswerUncheckedCreateNestedOneWithoutForoInput
    responses?: ResponseUncheckedCreateNestedOneWithoutForoInput
  }

  export type ForoUpdateInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUpdateOneWithoutForoNestedInput
    responses?: ResponseUpdateOneWithoutForoNestedInput
    comunity?: ComunityUpdateOneRequiredWithoutForosNestedInput
  }

  export type ForoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comunityId?: IntFieldUpdateOperationsInput | number
    answers?: AnswerUncheckedUpdateOneWithoutForoNestedInput
    responses?: ResponseUncheckedUpdateOneWithoutForoNestedInput
  }

  export type ForoCreateManyInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    comunityId: number
  }

  export type ForoUpdateManyMutationInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ForoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comunityId?: IntFieldUpdateOperationsInput | number
  }

  export type AnswerCreateInput = {
    message?: string | null
    foro: ForoCreateNestedOneWithoutAnswersInput
    responses?: ResponseCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUncheckedCreateInput = {
    id?: number
    message?: string | null
    foroId: number
    responses?: ResponseUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUpdateInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foro?: ForoUpdateOneRequiredWithoutAnswersNestedInput
    responses?: ResponseUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
    responses?: ResponseUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerCreateManyInput = {
    id?: number
    message?: string | null
    foroId: number
  }

  export type AnswerUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnswerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
  }

  export type ResponseCreateInput = {
    message?: string | null
    foro: ForoCreateNestedOneWithoutResponsesInput
    answer: AnswerCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateInput = {
    id?: number
    message?: string | null
    foroId: number
    answerId: number
  }

  export type ResponseUpdateInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foro?: ForoUpdateOneRequiredWithoutResponsesNestedInput
    answer?: AnswerUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
  }

  export type ResponseCreateManyInput = {
    id?: number
    message?: string | null
    foroId: number
    answerId: number
  }

  export type ResponseUpdateManyMutationInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ResponseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
    answerId?: IntFieldUpdateOperationsInput | number
  }

  export type RolCreateInput = {
    name: string
    links?: LinkCreateNestedManyWithoutRolInput
  }

  export type RolUncheckedCreateInput = {
    id?: number
    name: string
    links?: LinkUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    links?: LinkUpdateManyWithoutRolNestedInput
  }

  export type RolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    links?: LinkUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolCreateManyInput = {
    id?: number
    name: string
  }

  export type RolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LinkCreateInput = {
    name: string
    Link: string
    rol: RolCreateNestedOneWithoutLinksInput
    userLineLink?: user_line_linkCreateNestedManyWithoutLinkInput
  }

  export type LinkUncheckedCreateInput = {
    id?: number
    rolId: number
    name: string
    Link: string
    userLineLink?: user_line_linkUncheckedCreateNestedManyWithoutLinkInput
  }

  export type LinkUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
    rol?: RolUpdateOneRequiredWithoutLinksNestedInput
    userLineLink?: user_line_linkUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
    userLineLink?: user_line_linkUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type LinkCreateManyInput = {
    id?: number
    rolId: number
    name: string
    Link: string
  }

  export type LinkUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
  }

  export type LinkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
  }

  export type user_line_linkCreateInput = {
    link: LinkCreateNestedOneWithoutUserLineLinkInput
    user: UserCreateNestedOneWithoutUser_line_linkInput
  }

  export type user_line_linkUncheckedCreateInput = {
    id?: number
    linkId: number
    userId: number
  }

  export type user_line_linkUpdateInput = {
    link?: LinkUpdateOneRequiredWithoutUserLineLinkNestedInput
    user?: UserUpdateOneRequiredWithoutUser_line_linkNestedInput
  }

  export type user_line_linkUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    linkId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type user_line_linkCreateManyInput = {
    id?: number
    linkId: number
    userId: number
  }

  export type user_line_linkUpdateManyMutationInput = {

  }

  export type user_line_linkUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    linkId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type CategoryCreateInput = {
    name: string
    description?: string | null
    products?: ProductCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    products?: ProductUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    products?: ProductUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceCreateInput = {
    name: string
    DATE_START?: Date | string | null
    DATE_END?: Date | string | null
    products?: ProductCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: number
    name: string
    DATE_START?: Date | string | null
    DATE_END?: Date | string | null
    products?: ProductUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    products?: ProductUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: number
    name: string
    DATE_START?: Date | string | null
    DATE_END?: Date | string | null
  }

  export type ServiceUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProductCreateInput = {
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    user: UserCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    userId: number
    categoryId?: number | null
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    userId: number
    categoryId?: number | null
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type CustomerCreateInput = {
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    invices?: InvoiceCreateNestedManyWithoutCustomerInput
    publications?: PublicationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    invices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
    publications?: PublicationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    invices?: InvoiceUpdateManyWithoutCustomerNestedInput
    publications?: PublicationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    invices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
  }

  export type CustomerUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceCreateInput = {
    date: Date | string
    customer: CustomerCreateNestedOneWithoutInvicesInput
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: number
    customerId: number
    date: Date | string
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvicesNestedInput
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: number
    customerId: number
    date: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Inv_Line_ProCreateInput = {
    product: ProductCreateNestedOneWithoutInv_line_prosInput
    invoice: InvoiceCreateNestedOneWithoutInv_line_prosInput
  }

  export type Inv_Line_ProUncheckedCreateInput = {
    id?: number
    productId: number
    invoiceId: number
  }

  export type Inv_Line_ProUpdateInput = {
    product?: ProductUpdateOneRequiredWithoutInv_line_prosNestedInput
    invoice?: InvoiceUpdateOneRequiredWithoutInv_line_prosNestedInput
  }

  export type Inv_Line_ProUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
  }

  export type Inv_Line_ProCreateManyInput = {
    id?: number
    productId: number
    invoiceId: number
  }

  export type Inv_Line_ProUpdateManyMutationInput = {

  }

  export type Inv_Line_ProUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
  }

  export type PublicationCreateInput = {
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    customer?: CustomerCreateNestedOneWithoutPublicationsInput
    user?: UserCreateNestedOneWithoutPublicationsInput
    reactios?: ReactCreateNestedManyWithoutPublicationInput
    comments?: CommentCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    reactios?: ReactUncheckedCreateNestedManyWithoutPublicationInput
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutPublicationsNestedInput
    user?: UserUpdateOneWithoutPublicationsNestedInput
    reactios?: ReactUpdateManyWithoutPublicationNestedInput
    comments?: CommentUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reactios?: ReactUncheckedUpdateManyWithoutPublicationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationCreateManyInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
  }

  export type PublicationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PublicationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReactCreateInput = {
    name: string
    publication: PublicationCreateNestedOneWithoutReactiosInput
  }

  export type ReactUncheckedCreateInput = {
    id?: number
    publicationId: number
    name: string
  }

  export type ReactUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    publication?: PublicationUpdateOneRequiredWithoutReactiosNestedInput
  }

  export type ReactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReactCreateManyInput = {
    id?: number
    publicationId: number
    name: string
  }

  export type ReactUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateInput = {
    text: string
    publication: PublicationCreateNestedOneWithoutCommentsInput
  }

  export type CommentUncheckedCreateInput = {
    id?: number
    publicationId: number
    text: string
  }

  export type CommentUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string
    publication?: PublicationUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentCreateManyInput = {
    id?: number
    publicationId: number
    text: string
  }

  export type CommentUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    publicationId?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ComunityListRelationFilter = {
    every?: ComunityWhereInput
    some?: ComunityWhereInput
    none?: ComunityWhereInput
  }

  export type FollowerListRelationFilter = {
    every?: FollowerWhereInput
    some?: FollowerWhereInput
    none?: FollowerWhereInput
  }

  export type User_line_linkListRelationFilter = {
    every?: user_line_linkWhereInput
    some?: user_line_linkWhereInput
    none?: user_line_linkWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type PublicationListRelationFilter = {
    every?: PublicationWhereInput
    some?: PublicationWhereInput
    none?: PublicationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ComunityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_line_linkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    semestre?: SortOrder
    status?: SortOrder
    alias?: SortOrder
    biography?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    semestre?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    semestre?: SortOrder
    status?: SortOrder
    alias?: SortOrder
    biography?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    semestre?: SortOrder
    status?: SortOrder
    alias?: SortOrder
    biography?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    semestre?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ComunityNullableRelationFilter = {
    is?: ComunityWhereInput | null
    isNot?: ComunityWhereInput | null
  }

  export type FollowerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type FollowerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrder
  }

  export type FollowerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type FollowerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type FollowerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    comunityId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ForoListRelationFilter = {
    every?: ForoWhereInput
    some?: ForoWhereInput
    none?: ForoWhereInput
  }

  export type ForoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComunityCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date_start?: SortOrder
  }

  export type ComunityAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ComunityMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date_start?: SortOrder
  }

  export type ComunityMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    date_start?: SortOrder
  }

  export type ComunitySumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AnswerNullableRelationFilter = {
    is?: AnswerWhereInput | null
    isNot?: AnswerWhereInput | null
  }

  export type ResponseNullableRelationFilter = {
    is?: ResponseWhereInput | null
    isNot?: ResponseWhereInput | null
  }

  export type ComunityRelationFilter = {
    is?: ComunityWhereInput
    isNot?: ComunityWhereInput
  }

  export type ForoCountOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    date_publication?: SortOrder
    date_update?: SortOrder
    comunityId?: SortOrder
  }

  export type ForoAvgOrderByAggregateInput = {
    id?: SortOrder
    comunityId?: SortOrder
  }

  export type ForoMaxOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    date_publication?: SortOrder
    date_update?: SortOrder
    comunityId?: SortOrder
  }

  export type ForoMinOrderByAggregateInput = {
    id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    date_publication?: SortOrder
    date_update?: SortOrder
    comunityId?: SortOrder
  }

  export type ForoSumOrderByAggregateInput = {
    id?: SortOrder
    comunityId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ForoRelationFilter = {
    is?: ForoWhereInput
    isNot?: ForoWhereInput
  }

  export type ResponseListRelationFilter = {
    every?: ResponseWhereInput
    some?: ResponseWhereInput
    none?: ResponseWhereInput
  }

  export type ResponseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnswerCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
  }

  export type AnswerAvgOrderByAggregateInput = {
    id?: SortOrder
    foroId?: SortOrder
  }

  export type AnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
  }

  export type AnswerMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
  }

  export type AnswerSumOrderByAggregateInput = {
    id?: SortOrder
    foroId?: SortOrder
  }

  export type AnswerRelationFilter = {
    is?: AnswerWhereInput
    isNot?: AnswerWhereInput
  }

  export type ResponseCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
  }

  export type ResponseAvgOrderByAggregateInput = {
    id?: SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
  }

  export type ResponseMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
  }

  export type ResponseMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
  }

  export type ResponseSumOrderByAggregateInput = {
    id?: SortOrder
    foroId?: SortOrder
    answerId?: SortOrder
  }

  export type LinkListRelationFilter = {
    every?: LinkWhereInput
    some?: LinkWhereInput
    none?: LinkWhereInput
  }

  export type LinkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type RolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolRelationFilter = {
    is?: RolWhereInput
    isNot?: RolWhereInput
  }

  export type LinkCountOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    name?: SortOrder
    Link?: SortOrder
  }

  export type LinkAvgOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
  }

  export type LinkMaxOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    name?: SortOrder
    Link?: SortOrder
  }

  export type LinkMinOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
    name?: SortOrder
    Link?: SortOrder
  }

  export type LinkSumOrderByAggregateInput = {
    id?: SortOrder
    rolId?: SortOrder
  }

  export type LinkRelationFilter = {
    is?: LinkWhereInput
    isNot?: LinkWhereInput
  }

  export type user_line_linkCountOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
  }

  export type user_line_linkAvgOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
  }

  export type user_line_linkMaxOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
  }

  export type user_line_linkMinOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
  }

  export type user_line_linkSumOrderByAggregateInput = {
    id?: SortOrder
    linkId?: SortOrder
    userId?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    DATE_START?: SortOrder
    DATE_END?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    DATE_START?: SortOrder
    DATE_END?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    DATE_START?: SortOrder
    DATE_END?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type CategoryNullableRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type ServiceNullableRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type Inv_Line_ProListRelationFilter = {
    every?: Inv_Line_ProWhereInput
    some?: Inv_Line_ProWhereInput
    none?: Inv_Line_ProWhereInput
  }

  export type Inv_Line_ProOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    serviceid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    date_create?: SortOrder
    status?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    serviceid?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    serviceid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    date_create?: SortOrder
    status?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    serviceid?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    date_create?: SortOrder
    status?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    categoryId?: SortOrder
    serviceid?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    Company?: SortOrder
    city?: SortOrder
    job?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    Company?: SortOrder
    city?: SortOrder
    job?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    lname?: SortOrder
    phone?: SortOrder
    idCard?: SortOrder
    Company?: SortOrder
    city?: SortOrder
    job?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    date?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type Inv_Line_ProCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
  }

  export type Inv_Line_ProAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
  }

  export type Inv_Line_ProMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
  }

  export type Inv_Line_ProMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
  }

  export type Inv_Line_ProSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    invoiceId?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ReactListRelationFilter = {
    every?: ReactWhereInput
    some?: ReactWhereInput
    none?: ReactWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PublicationCountOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PublicationAvgOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
  }

  export type PublicationMaxOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PublicationMinOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    image?: SortOrder
    date?: SortOrder
    status?: SortOrder
  }

  export type PublicationSumOrderByAggregateInput = {
    id?: SortOrder
    customerId?: SortOrder
    userId?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type PublicationRelationFilter = {
    is?: PublicationWhereInput
    isNot?: PublicationWhereInput
  }

  export type ReactCountOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    name?: SortOrder
  }

  export type ReactAvgOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
  }

  export type ReactMaxOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    name?: SortOrder
  }

  export type ReactMinOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    name?: SortOrder
  }

  export type ReactSumOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    text?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    text?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
    text?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    id?: SortOrder
    publicationId?: SortOrder
  }

  export type ComunityCreateNestedManyWithoutUserInput = {
    create?: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput> | ComunityCreateWithoutUserInput[] | ComunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComunityCreateOrConnectWithoutUserInput | ComunityCreateOrConnectWithoutUserInput[]
    createMany?: ComunityCreateManyUserInputEnvelope
    connect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
  }

  export type FollowerCreateNestedManyWithoutUserInput = {
    create?: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput> | FollowerCreateWithoutUserInput[] | FollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutUserInput | FollowerCreateOrConnectWithoutUserInput[]
    createMany?: FollowerCreateManyUserInputEnvelope
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
  }

  export type user_line_linkCreateNestedManyWithoutUserInput = {
    create?: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput> | user_line_linkCreateWithoutUserInput[] | user_line_linkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutUserInput | user_line_linkCreateOrConnectWithoutUserInput[]
    createMany?: user_line_linkCreateManyUserInputEnvelope
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type ComunityUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput> | ComunityCreateWithoutUserInput[] | ComunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComunityCreateOrConnectWithoutUserInput | ComunityCreateOrConnectWithoutUserInput[]
    createMany?: ComunityCreateManyUserInputEnvelope
    connect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
  }

  export type FollowerUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput> | FollowerCreateWithoutUserInput[] | FollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutUserInput | FollowerCreateOrConnectWithoutUserInput[]
    createMany?: FollowerCreateManyUserInputEnvelope
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
  }

  export type user_line_linkUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput> | user_line_linkCreateWithoutUserInput[] | user_line_linkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutUserInput | user_line_linkCreateOrConnectWithoutUserInput[]
    createMany?: user_line_linkCreateManyUserInputEnvelope
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ComunityUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput> | ComunityCreateWithoutUserInput[] | ComunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComunityCreateOrConnectWithoutUserInput | ComunityCreateOrConnectWithoutUserInput[]
    upsert?: ComunityUpsertWithWhereUniqueWithoutUserInput | ComunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComunityCreateManyUserInputEnvelope
    set?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    disconnect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    delete?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    connect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    update?: ComunityUpdateWithWhereUniqueWithoutUserInput | ComunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComunityUpdateManyWithWhereWithoutUserInput | ComunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComunityScalarWhereInput | ComunityScalarWhereInput[]
  }

  export type FollowerUpdateManyWithoutUserNestedInput = {
    create?: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput> | FollowerCreateWithoutUserInput[] | FollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutUserInput | FollowerCreateOrConnectWithoutUserInput[]
    upsert?: FollowerUpsertWithWhereUniqueWithoutUserInput | FollowerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FollowerCreateManyUserInputEnvelope
    set?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    disconnect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    delete?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    update?: FollowerUpdateWithWhereUniqueWithoutUserInput | FollowerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FollowerUpdateManyWithWhereWithoutUserInput | FollowerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
  }

  export type user_line_linkUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput> | user_line_linkCreateWithoutUserInput[] | user_line_linkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutUserInput | user_line_linkCreateOrConnectWithoutUserInput[]
    upsert?: user_line_linkUpsertWithWhereUniqueWithoutUserInput | user_line_linkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_line_linkCreateManyUserInputEnvelope
    set?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    disconnect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    delete?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    update?: user_line_linkUpdateWithWhereUniqueWithoutUserInput | user_line_linkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_line_linkUpdateManyWithWhereWithoutUserInput | user_line_linkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutUserInput | PublicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutUserInput | PublicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutUserInput | PublicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type ComunityUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput> | ComunityCreateWithoutUserInput[] | ComunityUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ComunityCreateOrConnectWithoutUserInput | ComunityCreateOrConnectWithoutUserInput[]
    upsert?: ComunityUpsertWithWhereUniqueWithoutUserInput | ComunityUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ComunityCreateManyUserInputEnvelope
    set?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    disconnect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    delete?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    connect?: ComunityWhereUniqueInput | ComunityWhereUniqueInput[]
    update?: ComunityUpdateWithWhereUniqueWithoutUserInput | ComunityUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ComunityUpdateManyWithWhereWithoutUserInput | ComunityUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ComunityScalarWhereInput | ComunityScalarWhereInput[]
  }

  export type FollowerUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput> | FollowerCreateWithoutUserInput[] | FollowerUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutUserInput | FollowerCreateOrConnectWithoutUserInput[]
    upsert?: FollowerUpsertWithWhereUniqueWithoutUserInput | FollowerUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FollowerCreateManyUserInputEnvelope
    set?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    disconnect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    delete?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    update?: FollowerUpdateWithWhereUniqueWithoutUserInput | FollowerUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FollowerUpdateManyWithWhereWithoutUserInput | FollowerUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
  }

  export type user_line_linkUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput> | user_line_linkCreateWithoutUserInput[] | user_line_linkUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutUserInput | user_line_linkCreateOrConnectWithoutUserInput[]
    upsert?: user_line_linkUpsertWithWhereUniqueWithoutUserInput | user_line_linkUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_line_linkCreateManyUserInputEnvelope
    set?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    disconnect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    delete?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    update?: user_line_linkUpdateWithWhereUniqueWithoutUserInput | user_line_linkUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_line_linkUpdateManyWithWhereWithoutUserInput | user_line_linkUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput> | ProductCreateWithoutUserInput[] | ProductUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutUserInput | ProductCreateOrConnectWithoutUserInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutUserInput | ProductUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProductCreateManyUserInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutUserInput | ProductUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutUserInput | ProductUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput> | PublicationCreateWithoutUserInput[] | PublicationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutUserInput | PublicationCreateOrConnectWithoutUserInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutUserInput | PublicationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PublicationCreateManyUserInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutUserInput | PublicationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutUserInput | PublicationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFollowersInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    connect?: UserWhereUniqueInput
  }

  export type ComunityCreateNestedOneWithoutFollowersInput = {
    create?: XOR<ComunityCreateWithoutFollowersInput, ComunityUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: ComunityCreateOrConnectWithoutFollowersInput
    connect?: ComunityWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutFollowersNestedInput = {
    create?: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: UserCreateOrConnectWithoutFollowersInput
    upsert?: UserUpsertWithoutFollowersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFollowersInput, UserUpdateWithoutFollowersInput>, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type ComunityUpdateOneWithoutFollowersNestedInput = {
    create?: XOR<ComunityCreateWithoutFollowersInput, ComunityUncheckedCreateWithoutFollowersInput>
    connectOrCreate?: ComunityCreateOrConnectWithoutFollowersInput
    upsert?: ComunityUpsertWithoutFollowersInput
    disconnect?: ComunityWhereInput | boolean
    delete?: ComunityWhereInput | boolean
    connect?: ComunityWhereUniqueInput
    update?: XOR<XOR<ComunityUpdateToOneWithWhereWithoutFollowersInput, ComunityUpdateWithoutFollowersInput>, ComunityUncheckedUpdateWithoutFollowersInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserCreateNestedOneWithoutCommunitiesInput = {
    create?: XOR<UserCreateWithoutCommunitiesInput, UserUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunitiesInput
    connect?: UserWhereUniqueInput
  }

  export type FollowerCreateNestedManyWithoutCommunityInput = {
    create?: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput> | FollowerCreateWithoutCommunityInput[] | FollowerUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutCommunityInput | FollowerCreateOrConnectWithoutCommunityInput[]
    createMany?: FollowerCreateManyCommunityInputEnvelope
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
  }

  export type ForoCreateNestedManyWithoutComunityInput = {
    create?: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput> | ForoCreateWithoutComunityInput[] | ForoUncheckedCreateWithoutComunityInput[]
    connectOrCreate?: ForoCreateOrConnectWithoutComunityInput | ForoCreateOrConnectWithoutComunityInput[]
    createMany?: ForoCreateManyComunityInputEnvelope
    connect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
  }

  export type FollowerUncheckedCreateNestedManyWithoutCommunityInput = {
    create?: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput> | FollowerCreateWithoutCommunityInput[] | FollowerUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutCommunityInput | FollowerCreateOrConnectWithoutCommunityInput[]
    createMany?: FollowerCreateManyCommunityInputEnvelope
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
  }

  export type ForoUncheckedCreateNestedManyWithoutComunityInput = {
    create?: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput> | ForoCreateWithoutComunityInput[] | ForoUncheckedCreateWithoutComunityInput[]
    connectOrCreate?: ForoCreateOrConnectWithoutComunityInput | ForoCreateOrConnectWithoutComunityInput[]
    createMany?: ForoCreateManyComunityInputEnvelope
    connect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutCommunitiesNestedInput = {
    create?: XOR<UserCreateWithoutCommunitiesInput, UserUncheckedCreateWithoutCommunitiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommunitiesInput
    upsert?: UserUpsertWithoutCommunitiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommunitiesInput, UserUpdateWithoutCommunitiesInput>, UserUncheckedUpdateWithoutCommunitiesInput>
  }

  export type FollowerUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput> | FollowerCreateWithoutCommunityInput[] | FollowerUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutCommunityInput | FollowerCreateOrConnectWithoutCommunityInput[]
    upsert?: FollowerUpsertWithWhereUniqueWithoutCommunityInput | FollowerUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: FollowerCreateManyCommunityInputEnvelope
    set?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    disconnect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    delete?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    update?: FollowerUpdateWithWhereUniqueWithoutCommunityInput | FollowerUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: FollowerUpdateManyWithWhereWithoutCommunityInput | FollowerUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
  }

  export type ForoUpdateManyWithoutComunityNestedInput = {
    create?: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput> | ForoCreateWithoutComunityInput[] | ForoUncheckedCreateWithoutComunityInput[]
    connectOrCreate?: ForoCreateOrConnectWithoutComunityInput | ForoCreateOrConnectWithoutComunityInput[]
    upsert?: ForoUpsertWithWhereUniqueWithoutComunityInput | ForoUpsertWithWhereUniqueWithoutComunityInput[]
    createMany?: ForoCreateManyComunityInputEnvelope
    set?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    disconnect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    delete?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    connect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    update?: ForoUpdateWithWhereUniqueWithoutComunityInput | ForoUpdateWithWhereUniqueWithoutComunityInput[]
    updateMany?: ForoUpdateManyWithWhereWithoutComunityInput | ForoUpdateManyWithWhereWithoutComunityInput[]
    deleteMany?: ForoScalarWhereInput | ForoScalarWhereInput[]
  }

  export type FollowerUncheckedUpdateManyWithoutCommunityNestedInput = {
    create?: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput> | FollowerCreateWithoutCommunityInput[] | FollowerUncheckedCreateWithoutCommunityInput[]
    connectOrCreate?: FollowerCreateOrConnectWithoutCommunityInput | FollowerCreateOrConnectWithoutCommunityInput[]
    upsert?: FollowerUpsertWithWhereUniqueWithoutCommunityInput | FollowerUpsertWithWhereUniqueWithoutCommunityInput[]
    createMany?: FollowerCreateManyCommunityInputEnvelope
    set?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    disconnect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    delete?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    connect?: FollowerWhereUniqueInput | FollowerWhereUniqueInput[]
    update?: FollowerUpdateWithWhereUniqueWithoutCommunityInput | FollowerUpdateWithWhereUniqueWithoutCommunityInput[]
    updateMany?: FollowerUpdateManyWithWhereWithoutCommunityInput | FollowerUpdateManyWithWhereWithoutCommunityInput[]
    deleteMany?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
  }

  export type ForoUncheckedUpdateManyWithoutComunityNestedInput = {
    create?: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput> | ForoCreateWithoutComunityInput[] | ForoUncheckedCreateWithoutComunityInput[]
    connectOrCreate?: ForoCreateOrConnectWithoutComunityInput | ForoCreateOrConnectWithoutComunityInput[]
    upsert?: ForoUpsertWithWhereUniqueWithoutComunityInput | ForoUpsertWithWhereUniqueWithoutComunityInput[]
    createMany?: ForoCreateManyComunityInputEnvelope
    set?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    disconnect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    delete?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    connect?: ForoWhereUniqueInput | ForoWhereUniqueInput[]
    update?: ForoUpdateWithWhereUniqueWithoutComunityInput | ForoUpdateWithWhereUniqueWithoutComunityInput[]
    updateMany?: ForoUpdateManyWithWhereWithoutComunityInput | ForoUpdateManyWithWhereWithoutComunityInput[]
    deleteMany?: ForoScalarWhereInput | ForoScalarWhereInput[]
  }

  export type AnswerCreateNestedOneWithoutForoInput = {
    create?: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutForoInput
    connect?: AnswerWhereUniqueInput
  }

  export type ResponseCreateNestedOneWithoutForoInput = {
    create?: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutForoInput
    connect?: ResponseWhereUniqueInput
  }

  export type ComunityCreateNestedOneWithoutForosInput = {
    create?: XOR<ComunityCreateWithoutForosInput, ComunityUncheckedCreateWithoutForosInput>
    connectOrCreate?: ComunityCreateOrConnectWithoutForosInput
    connect?: ComunityWhereUniqueInput
  }

  export type AnswerUncheckedCreateNestedOneWithoutForoInput = {
    create?: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutForoInput
    connect?: AnswerWhereUniqueInput
  }

  export type ResponseUncheckedCreateNestedOneWithoutForoInput = {
    create?: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutForoInput
    connect?: ResponseWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AnswerUpdateOneWithoutForoNestedInput = {
    create?: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutForoInput
    upsert?: AnswerUpsertWithoutForoInput
    disconnect?: AnswerWhereInput | boolean
    delete?: AnswerWhereInput | boolean
    connect?: AnswerWhereUniqueInput
    update?: XOR<XOR<AnswerUpdateToOneWithWhereWithoutForoInput, AnswerUpdateWithoutForoInput>, AnswerUncheckedUpdateWithoutForoInput>
  }

  export type ResponseUpdateOneWithoutForoNestedInput = {
    create?: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutForoInput
    upsert?: ResponseUpsertWithoutForoInput
    disconnect?: ResponseWhereInput | boolean
    delete?: ResponseWhereInput | boolean
    connect?: ResponseWhereUniqueInput
    update?: XOR<XOR<ResponseUpdateToOneWithWhereWithoutForoInput, ResponseUpdateWithoutForoInput>, ResponseUncheckedUpdateWithoutForoInput>
  }

  export type ComunityUpdateOneRequiredWithoutForosNestedInput = {
    create?: XOR<ComunityCreateWithoutForosInput, ComunityUncheckedCreateWithoutForosInput>
    connectOrCreate?: ComunityCreateOrConnectWithoutForosInput
    upsert?: ComunityUpsertWithoutForosInput
    connect?: ComunityWhereUniqueInput
    update?: XOR<XOR<ComunityUpdateToOneWithWhereWithoutForosInput, ComunityUpdateWithoutForosInput>, ComunityUncheckedUpdateWithoutForosInput>
  }

  export type AnswerUncheckedUpdateOneWithoutForoNestedInput = {
    create?: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutForoInput
    upsert?: AnswerUpsertWithoutForoInput
    disconnect?: AnswerWhereInput | boolean
    delete?: AnswerWhereInput | boolean
    connect?: AnswerWhereUniqueInput
    update?: XOR<XOR<AnswerUpdateToOneWithWhereWithoutForoInput, AnswerUpdateWithoutForoInput>, AnswerUncheckedUpdateWithoutForoInput>
  }

  export type ResponseUncheckedUpdateOneWithoutForoNestedInput = {
    create?: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
    connectOrCreate?: ResponseCreateOrConnectWithoutForoInput
    upsert?: ResponseUpsertWithoutForoInput
    disconnect?: ResponseWhereInput | boolean
    delete?: ResponseWhereInput | boolean
    connect?: ResponseWhereUniqueInput
    update?: XOR<XOR<ResponseUpdateToOneWithWhereWithoutForoInput, ResponseUpdateWithoutForoInput>, ResponseUncheckedUpdateWithoutForoInput>
  }

  export type ForoCreateNestedOneWithoutAnswersInput = {
    create?: XOR<ForoCreateWithoutAnswersInput, ForoUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ForoCreateOrConnectWithoutAnswersInput
    connect?: ForoWhereUniqueInput
  }

  export type ResponseCreateNestedManyWithoutAnswerInput = {
    create?: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput> | ResponseCreateWithoutAnswerInput[] | ResponseUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutAnswerInput | ResponseCreateOrConnectWithoutAnswerInput[]
    createMany?: ResponseCreateManyAnswerInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ResponseUncheckedCreateNestedManyWithoutAnswerInput = {
    create?: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput> | ResponseCreateWithoutAnswerInput[] | ResponseUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutAnswerInput | ResponseCreateOrConnectWithoutAnswerInput[]
    createMany?: ResponseCreateManyAnswerInputEnvelope
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
  }

  export type ForoUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<ForoCreateWithoutAnswersInput, ForoUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: ForoCreateOrConnectWithoutAnswersInput
    upsert?: ForoUpsertWithoutAnswersInput
    connect?: ForoWhereUniqueInput
    update?: XOR<XOR<ForoUpdateToOneWithWhereWithoutAnswersInput, ForoUpdateWithoutAnswersInput>, ForoUncheckedUpdateWithoutAnswersInput>
  }

  export type ResponseUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput> | ResponseCreateWithoutAnswerInput[] | ResponseUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutAnswerInput | ResponseCreateOrConnectWithoutAnswerInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutAnswerInput | ResponseUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: ResponseCreateManyAnswerInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutAnswerInput | ResponseUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutAnswerInput | ResponseUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ResponseUncheckedUpdateManyWithoutAnswerNestedInput = {
    create?: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput> | ResponseCreateWithoutAnswerInput[] | ResponseUncheckedCreateWithoutAnswerInput[]
    connectOrCreate?: ResponseCreateOrConnectWithoutAnswerInput | ResponseCreateOrConnectWithoutAnswerInput[]
    upsert?: ResponseUpsertWithWhereUniqueWithoutAnswerInput | ResponseUpsertWithWhereUniqueWithoutAnswerInput[]
    createMany?: ResponseCreateManyAnswerInputEnvelope
    set?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    disconnect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    delete?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    connect?: ResponseWhereUniqueInput | ResponseWhereUniqueInput[]
    update?: ResponseUpdateWithWhereUniqueWithoutAnswerInput | ResponseUpdateWithWhereUniqueWithoutAnswerInput[]
    updateMany?: ResponseUpdateManyWithWhereWithoutAnswerInput | ResponseUpdateManyWithWhereWithoutAnswerInput[]
    deleteMany?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
  }

  export type ForoCreateNestedOneWithoutResponsesInput = {
    create?: XOR<ForoCreateWithoutResponsesInput, ForoUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ForoCreateOrConnectWithoutResponsesInput
    connect?: ForoWhereUniqueInput
  }

  export type AnswerCreateNestedOneWithoutResponsesInput = {
    create?: XOR<AnswerCreateWithoutResponsesInput, AnswerUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutResponsesInput
    connect?: AnswerWhereUniqueInput
  }

  export type ForoUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<ForoCreateWithoutResponsesInput, ForoUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: ForoCreateOrConnectWithoutResponsesInput
    upsert?: ForoUpsertWithoutResponsesInput
    connect?: ForoWhereUniqueInput
    update?: XOR<XOR<ForoUpdateToOneWithWhereWithoutResponsesInput, ForoUpdateWithoutResponsesInput>, ForoUncheckedUpdateWithoutResponsesInput>
  }

  export type AnswerUpdateOneRequiredWithoutResponsesNestedInput = {
    create?: XOR<AnswerCreateWithoutResponsesInput, AnswerUncheckedCreateWithoutResponsesInput>
    connectOrCreate?: AnswerCreateOrConnectWithoutResponsesInput
    upsert?: AnswerUpsertWithoutResponsesInput
    connect?: AnswerWhereUniqueInput
    update?: XOR<XOR<AnswerUpdateToOneWithWhereWithoutResponsesInput, AnswerUpdateWithoutResponsesInput>, AnswerUncheckedUpdateWithoutResponsesInput>
  }

  export type LinkCreateNestedManyWithoutRolInput = {
    create?: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput> | LinkCreateWithoutRolInput[] | LinkUncheckedCreateWithoutRolInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutRolInput | LinkCreateOrConnectWithoutRolInput[]
    createMany?: LinkCreateManyRolInputEnvelope
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
  }

  export type LinkUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput> | LinkCreateWithoutRolInput[] | LinkUncheckedCreateWithoutRolInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutRolInput | LinkCreateOrConnectWithoutRolInput[]
    createMany?: LinkCreateManyRolInputEnvelope
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
  }

  export type LinkUpdateManyWithoutRolNestedInput = {
    create?: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput> | LinkCreateWithoutRolInput[] | LinkUncheckedCreateWithoutRolInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutRolInput | LinkCreateOrConnectWithoutRolInput[]
    upsert?: LinkUpsertWithWhereUniqueWithoutRolInput | LinkUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: LinkCreateManyRolInputEnvelope
    set?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    disconnect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    delete?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    update?: LinkUpdateWithWhereUniqueWithoutRolInput | LinkUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: LinkUpdateManyWithWhereWithoutRolInput | LinkUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: LinkScalarWhereInput | LinkScalarWhereInput[]
  }

  export type LinkUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput> | LinkCreateWithoutRolInput[] | LinkUncheckedCreateWithoutRolInput[]
    connectOrCreate?: LinkCreateOrConnectWithoutRolInput | LinkCreateOrConnectWithoutRolInput[]
    upsert?: LinkUpsertWithWhereUniqueWithoutRolInput | LinkUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: LinkCreateManyRolInputEnvelope
    set?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    disconnect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    delete?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    connect?: LinkWhereUniqueInput | LinkWhereUniqueInput[]
    update?: LinkUpdateWithWhereUniqueWithoutRolInput | LinkUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: LinkUpdateManyWithWhereWithoutRolInput | LinkUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: LinkScalarWhereInput | LinkScalarWhereInput[]
  }

  export type RolCreateNestedOneWithoutLinksInput = {
    create?: XOR<RolCreateWithoutLinksInput, RolUncheckedCreateWithoutLinksInput>
    connectOrCreate?: RolCreateOrConnectWithoutLinksInput
    connect?: RolWhereUniqueInput
  }

  export type user_line_linkCreateNestedManyWithoutLinkInput = {
    create?: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput> | user_line_linkCreateWithoutLinkInput[] | user_line_linkUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutLinkInput | user_line_linkCreateOrConnectWithoutLinkInput[]
    createMany?: user_line_linkCreateManyLinkInputEnvelope
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
  }

  export type user_line_linkUncheckedCreateNestedManyWithoutLinkInput = {
    create?: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput> | user_line_linkCreateWithoutLinkInput[] | user_line_linkUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutLinkInput | user_line_linkCreateOrConnectWithoutLinkInput[]
    createMany?: user_line_linkCreateManyLinkInputEnvelope
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
  }

  export type RolUpdateOneRequiredWithoutLinksNestedInput = {
    create?: XOR<RolCreateWithoutLinksInput, RolUncheckedCreateWithoutLinksInput>
    connectOrCreate?: RolCreateOrConnectWithoutLinksInput
    upsert?: RolUpsertWithoutLinksInput
    connect?: RolWhereUniqueInput
    update?: XOR<XOR<RolUpdateToOneWithWhereWithoutLinksInput, RolUpdateWithoutLinksInput>, RolUncheckedUpdateWithoutLinksInput>
  }

  export type user_line_linkUpdateManyWithoutLinkNestedInput = {
    create?: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput> | user_line_linkCreateWithoutLinkInput[] | user_line_linkUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutLinkInput | user_line_linkCreateOrConnectWithoutLinkInput[]
    upsert?: user_line_linkUpsertWithWhereUniqueWithoutLinkInput | user_line_linkUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: user_line_linkCreateManyLinkInputEnvelope
    set?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    disconnect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    delete?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    update?: user_line_linkUpdateWithWhereUniqueWithoutLinkInput | user_line_linkUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: user_line_linkUpdateManyWithWhereWithoutLinkInput | user_line_linkUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
  }

  export type user_line_linkUncheckedUpdateManyWithoutLinkNestedInput = {
    create?: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput> | user_line_linkCreateWithoutLinkInput[] | user_line_linkUncheckedCreateWithoutLinkInput[]
    connectOrCreate?: user_line_linkCreateOrConnectWithoutLinkInput | user_line_linkCreateOrConnectWithoutLinkInput[]
    upsert?: user_line_linkUpsertWithWhereUniqueWithoutLinkInput | user_line_linkUpsertWithWhereUniqueWithoutLinkInput[]
    createMany?: user_line_linkCreateManyLinkInputEnvelope
    set?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    disconnect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    delete?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    connect?: user_line_linkWhereUniqueInput | user_line_linkWhereUniqueInput[]
    update?: user_line_linkUpdateWithWhereUniqueWithoutLinkInput | user_line_linkUpdateWithWhereUniqueWithoutLinkInput[]
    updateMany?: user_line_linkUpdateManyWithWhereWithoutLinkInput | user_line_linkUpdateManyWithWhereWithoutLinkInput[]
    deleteMany?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
  }

  export type LinkCreateNestedOneWithoutUserLineLinkInput = {
    create?: XOR<LinkCreateWithoutUserLineLinkInput, LinkUncheckedCreateWithoutUserLineLinkInput>
    connectOrCreate?: LinkCreateOrConnectWithoutUserLineLinkInput
    connect?: LinkWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUser_line_linkInput = {
    create?: XOR<UserCreateWithoutUser_line_linkInput, UserUncheckedCreateWithoutUser_line_linkInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_line_linkInput
    connect?: UserWhereUniqueInput
  }

  export type LinkUpdateOneRequiredWithoutUserLineLinkNestedInput = {
    create?: XOR<LinkCreateWithoutUserLineLinkInput, LinkUncheckedCreateWithoutUserLineLinkInput>
    connectOrCreate?: LinkCreateOrConnectWithoutUserLineLinkInput
    upsert?: LinkUpsertWithoutUserLineLinkInput
    connect?: LinkWhereUniqueInput
    update?: XOR<XOR<LinkUpdateToOneWithWhereWithoutUserLineLinkInput, LinkUpdateWithoutUserLineLinkInput>, LinkUncheckedUpdateWithoutUserLineLinkInput>
  }

  export type UserUpdateOneRequiredWithoutUser_line_linkNestedInput = {
    create?: XOR<UserCreateWithoutUser_line_linkInput, UserUncheckedCreateWithoutUser_line_linkInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_line_linkInput
    upsert?: UserUpsertWithoutUser_line_linkInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_line_linkInput, UserUpdateWithoutUser_line_linkInput>, UserUncheckedUpdateWithoutUser_line_linkInput>
  }

  export type ProductCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput> | ProductCreateWithoutCategoryInput[] | ProductUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutCategoryInput | ProductCreateOrConnectWithoutCategoryInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutCategoryInput | ProductUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ProductCreateManyCategoryInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutCategoryInput | ProductUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutCategoryInput | ProductUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput> | ProductCreateWithoutServiceInput[] | ProductUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutServiceInput | ProductCreateOrConnectWithoutServiceInput[]
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput> | ProductCreateWithoutServiceInput[] | ProductUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutServiceInput | ProductCreateOrConnectWithoutServiceInput[]
    createMany?: ProductCreateManyServiceInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput> | ProductCreateWithoutServiceInput[] | ProductUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutServiceInput | ProductCreateOrConnectWithoutServiceInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutServiceInput | ProductUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutServiceInput | ProductUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutServiceInput | ProductUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput> | ProductCreateWithoutServiceInput[] | ProductUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutServiceInput | ProductCreateOrConnectWithoutServiceInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutServiceInput | ProductUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ProductCreateManyServiceInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutServiceInput | ProductUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutServiceInput | ProductUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProductsInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    connect?: UserWhereUniqueInput
  }

  export type CategoryCreateNestedOneWithoutProductsInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    connect?: CategoryWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutProductsInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    connect?: ServiceWhereUniqueInput
  }

  export type Inv_Line_ProCreateNestedManyWithoutProductInput = {
    create?: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput> | Inv_Line_ProCreateWithoutProductInput[] | Inv_Line_ProUncheckedCreateWithoutProductInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutProductInput | Inv_Line_ProCreateOrConnectWithoutProductInput[]
    createMany?: Inv_Line_ProCreateManyProductInputEnvelope
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
  }

  export type Inv_Line_ProUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput> | Inv_Line_ProCreateWithoutProductInput[] | Inv_Line_ProUncheckedCreateWithoutProductInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutProductInput | Inv_Line_ProCreateOrConnectWithoutProductInput[]
    createMany?: Inv_Line_ProCreateManyProductInputEnvelope
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type UserUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProductsInput
    upsert?: UserUpsertWithoutProductsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProductsInput, UserUpdateWithoutProductsInput>, UserUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateOneWithoutProductsNestedInput = {
    create?: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutProductsInput
    upsert?: CategoryUpsertWithoutProductsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutProductsInput, CategoryUpdateWithoutProductsInput>, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type ServiceUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutProductsInput
    upsert?: ServiceUpsertWithoutProductsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutProductsInput, ServiceUpdateWithoutProductsInput>, ServiceUncheckedUpdateWithoutProductsInput>
  }

  export type Inv_Line_ProUpdateManyWithoutProductNestedInput = {
    create?: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput> | Inv_Line_ProCreateWithoutProductInput[] | Inv_Line_ProUncheckedCreateWithoutProductInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutProductInput | Inv_Line_ProCreateOrConnectWithoutProductInput[]
    upsert?: Inv_Line_ProUpsertWithWhereUniqueWithoutProductInput | Inv_Line_ProUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: Inv_Line_ProCreateManyProductInputEnvelope
    set?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    disconnect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    delete?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    update?: Inv_Line_ProUpdateWithWhereUniqueWithoutProductInput | Inv_Line_ProUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: Inv_Line_ProUpdateManyWithWhereWithoutProductInput | Inv_Line_ProUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
  }

  export type Inv_Line_ProUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput> | Inv_Line_ProCreateWithoutProductInput[] | Inv_Line_ProUncheckedCreateWithoutProductInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutProductInput | Inv_Line_ProCreateOrConnectWithoutProductInput[]
    upsert?: Inv_Line_ProUpsertWithWhereUniqueWithoutProductInput | Inv_Line_ProUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: Inv_Line_ProCreateManyProductInputEnvelope
    set?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    disconnect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    delete?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    update?: Inv_Line_ProUpdateWithWhereUniqueWithoutProductInput | Inv_Line_ProUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: Inv_Line_ProUpdateManyWithWhereWithoutProductInput | Inv_Line_ProUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
  }

  export type InvoiceCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PublicationCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput> | PublicationCreateWithoutCustomerInput[] | PublicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutCustomerInput | PublicationCreateOrConnectWithoutCustomerInput[]
    createMany?: PublicationCreateManyCustomerInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PublicationUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput> | PublicationCreateWithoutCustomerInput[] | PublicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutCustomerInput | PublicationCreateOrConnectWithoutCustomerInput[]
    createMany?: PublicationCreateManyCustomerInputEnvelope
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
  }

  export type InvoiceUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PublicationUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput> | PublicationCreateWithoutCustomerInput[] | PublicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutCustomerInput | PublicationCreateOrConnectWithoutCustomerInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutCustomerInput | PublicationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PublicationCreateManyCustomerInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutCustomerInput | PublicationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutCustomerInput | PublicationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput> | InvoiceCreateWithoutCustomerInput[] | InvoiceUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutCustomerInput | InvoiceCreateOrConnectWithoutCustomerInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutCustomerInput | InvoiceUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: InvoiceCreateManyCustomerInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutCustomerInput | InvoiceUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutCustomerInput | InvoiceUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PublicationUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput> | PublicationCreateWithoutCustomerInput[] | PublicationUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: PublicationCreateOrConnectWithoutCustomerInput | PublicationCreateOrConnectWithoutCustomerInput[]
    upsert?: PublicationUpsertWithWhereUniqueWithoutCustomerInput | PublicationUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: PublicationCreateManyCustomerInputEnvelope
    set?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    disconnect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    delete?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    connect?: PublicationWhereUniqueInput | PublicationWhereUniqueInput[]
    update?: PublicationUpdateWithWhereUniqueWithoutCustomerInput | PublicationUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: PublicationUpdateManyWithWhereWithoutCustomerInput | PublicationUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
  }

  export type CustomerCreateNestedOneWithoutInvicesInput = {
    create?: XOR<CustomerCreateWithoutInvicesInput, CustomerUncheckedCreateWithoutInvicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvicesInput
    connect?: CustomerWhereUniqueInput
  }

  export type Inv_Line_ProCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput> | Inv_Line_ProCreateWithoutInvoiceInput[] | Inv_Line_ProUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutInvoiceInput | Inv_Line_ProCreateOrConnectWithoutInvoiceInput[]
    createMany?: Inv_Line_ProCreateManyInvoiceInputEnvelope
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
  }

  export type Inv_Line_ProUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput> | Inv_Line_ProCreateWithoutInvoiceInput[] | Inv_Line_ProUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutInvoiceInput | Inv_Line_ProCreateOrConnectWithoutInvoiceInput[]
    createMany?: Inv_Line_ProCreateManyInvoiceInputEnvelope
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
  }

  export type CustomerUpdateOneRequiredWithoutInvicesNestedInput = {
    create?: XOR<CustomerCreateWithoutInvicesInput, CustomerUncheckedCreateWithoutInvicesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutInvicesInput
    upsert?: CustomerUpsertWithoutInvicesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutInvicesInput, CustomerUpdateWithoutInvicesInput>, CustomerUncheckedUpdateWithoutInvicesInput>
  }

  export type Inv_Line_ProUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput> | Inv_Line_ProCreateWithoutInvoiceInput[] | Inv_Line_ProUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutInvoiceInput | Inv_Line_ProCreateOrConnectWithoutInvoiceInput[]
    upsert?: Inv_Line_ProUpsertWithWhereUniqueWithoutInvoiceInput | Inv_Line_ProUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: Inv_Line_ProCreateManyInvoiceInputEnvelope
    set?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    disconnect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    delete?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    update?: Inv_Line_ProUpdateWithWhereUniqueWithoutInvoiceInput | Inv_Line_ProUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: Inv_Line_ProUpdateManyWithWhereWithoutInvoiceInput | Inv_Line_ProUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
  }

  export type Inv_Line_ProUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput> | Inv_Line_ProCreateWithoutInvoiceInput[] | Inv_Line_ProUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: Inv_Line_ProCreateOrConnectWithoutInvoiceInput | Inv_Line_ProCreateOrConnectWithoutInvoiceInput[]
    upsert?: Inv_Line_ProUpsertWithWhereUniqueWithoutInvoiceInput | Inv_Line_ProUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: Inv_Line_ProCreateManyInvoiceInputEnvelope
    set?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    disconnect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    delete?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    connect?: Inv_Line_ProWhereUniqueInput | Inv_Line_ProWhereUniqueInput[]
    update?: Inv_Line_ProUpdateWithWhereUniqueWithoutInvoiceInput | Inv_Line_ProUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: Inv_Line_ProUpdateManyWithWhereWithoutInvoiceInput | Inv_Line_ProUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutInv_line_prosInput = {
    create?: XOR<ProductCreateWithoutInv_line_prosInput, ProductUncheckedCreateWithoutInv_line_prosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInv_line_prosInput
    connect?: ProductWhereUniqueInput
  }

  export type InvoiceCreateNestedOneWithoutInv_line_prosInput = {
    create?: XOR<InvoiceCreateWithoutInv_line_prosInput, InvoiceUncheckedCreateWithoutInv_line_prosInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInv_line_prosInput
    connect?: InvoiceWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutInv_line_prosNestedInput = {
    create?: XOR<ProductCreateWithoutInv_line_prosInput, ProductUncheckedCreateWithoutInv_line_prosInput>
    connectOrCreate?: ProductCreateOrConnectWithoutInv_line_prosInput
    upsert?: ProductUpsertWithoutInv_line_prosInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutInv_line_prosInput, ProductUpdateWithoutInv_line_prosInput>, ProductUncheckedUpdateWithoutInv_line_prosInput>
  }

  export type InvoiceUpdateOneRequiredWithoutInv_line_prosNestedInput = {
    create?: XOR<InvoiceCreateWithoutInv_line_prosInput, InvoiceUncheckedCreateWithoutInv_line_prosInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutInv_line_prosInput
    upsert?: InvoiceUpsertWithoutInv_line_prosInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutInv_line_prosInput, InvoiceUpdateWithoutInv_line_prosInput>, InvoiceUncheckedUpdateWithoutInv_line_prosInput>
  }

  export type CustomerCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<CustomerCreateWithoutPublicationsInput, CustomerUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPublicationsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPublicationsInput = {
    create?: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationsInput
    connect?: UserWhereUniqueInput
  }

  export type ReactCreateNestedManyWithoutPublicationInput = {
    create?: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput> | ReactCreateWithoutPublicationInput[] | ReactUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ReactCreateOrConnectWithoutPublicationInput | ReactCreateOrConnectWithoutPublicationInput[]
    createMany?: ReactCreateManyPublicationInputEnvelope
    connect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutPublicationInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput> | ReactCreateWithoutPublicationInput[] | ReactUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ReactCreateOrConnectWithoutPublicationInput | ReactCreateOrConnectWithoutPublicationInput[]
    createMany?: ReactCreateManyPublicationInputEnvelope
    connect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPublicationInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Buffer | null
  }

  export type CustomerUpdateOneWithoutPublicationsNestedInput = {
    create?: XOR<CustomerCreateWithoutPublicationsInput, CustomerUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutPublicationsInput
    upsert?: CustomerUpsertWithoutPublicationsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutPublicationsInput, CustomerUpdateWithoutPublicationsInput>, CustomerUncheckedUpdateWithoutPublicationsInput>
  }

  export type UserUpdateOneWithoutPublicationsNestedInput = {
    create?: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPublicationsInput
    upsert?: UserUpsertWithoutPublicationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPublicationsInput, UserUpdateWithoutPublicationsInput>, UserUncheckedUpdateWithoutPublicationsInput>
  }

  export type ReactUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput> | ReactCreateWithoutPublicationInput[] | ReactUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ReactCreateOrConnectWithoutPublicationInput | ReactCreateOrConnectWithoutPublicationInput[]
    upsert?: ReactUpsertWithWhereUniqueWithoutPublicationInput | ReactUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: ReactCreateManyPublicationInputEnvelope
    set?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    disconnect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    delete?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    connect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    update?: ReactUpdateWithWhereUniqueWithoutPublicationInput | ReactUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: ReactUpdateManyWithWhereWithoutPublicationInput | ReactUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: ReactScalarWhereInput | ReactScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPublicationInput | CommentUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPublicationInput | CommentUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPublicationInput | CommentUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput> | ReactCreateWithoutPublicationInput[] | ReactUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: ReactCreateOrConnectWithoutPublicationInput | ReactCreateOrConnectWithoutPublicationInput[]
    upsert?: ReactUpsertWithWhereUniqueWithoutPublicationInput | ReactUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: ReactCreateManyPublicationInputEnvelope
    set?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    disconnect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    delete?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    connect?: ReactWhereUniqueInput | ReactWhereUniqueInput[]
    update?: ReactUpdateWithWhereUniqueWithoutPublicationInput | ReactUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: ReactUpdateManyWithWhereWithoutPublicationInput | ReactUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: ReactScalarWhereInput | ReactScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPublicationNestedInput = {
    create?: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput> | CommentCreateWithoutPublicationInput[] | CommentUncheckedCreateWithoutPublicationInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPublicationInput | CommentCreateOrConnectWithoutPublicationInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPublicationInput | CommentUpsertWithWhereUniqueWithoutPublicationInput[]
    createMany?: CommentCreateManyPublicationInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPublicationInput | CommentUpdateWithWhereUniqueWithoutPublicationInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPublicationInput | CommentUpdateManyWithWhereWithoutPublicationInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PublicationCreateNestedOneWithoutReactiosInput = {
    create?: XOR<PublicationCreateWithoutReactiosInput, PublicationUncheckedCreateWithoutReactiosInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutReactiosInput
    connect?: PublicationWhereUniqueInput
  }

  export type PublicationUpdateOneRequiredWithoutReactiosNestedInput = {
    create?: XOR<PublicationCreateWithoutReactiosInput, PublicationUncheckedCreateWithoutReactiosInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutReactiosInput
    upsert?: PublicationUpsertWithoutReactiosInput
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutReactiosInput, PublicationUpdateWithoutReactiosInput>, PublicationUncheckedUpdateWithoutReactiosInput>
  }

  export type PublicationCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutCommentsInput
    connect?: PublicationWhereUniqueInput
  }

  export type PublicationUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PublicationCreateOrConnectWithoutCommentsInput
    upsert?: PublicationUpsertWithoutCommentsInput
    connect?: PublicationWhereUniqueInput
    update?: XOR<XOR<PublicationUpdateToOneWithWhereWithoutCommentsInput, PublicationUpdateWithoutCommentsInput>, PublicationUncheckedUpdateWithoutCommentsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Buffer | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Buffer | BytesFieldRefInput<$PrismaModel> | null
    in?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Buffer[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Buffer | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type ComunityCreateWithoutUserInput = {
    name: string
    date_start: Date | string
    followers?: FollowerCreateNestedManyWithoutCommunityInput
    foros?: ForoCreateNestedManyWithoutComunityInput
  }

  export type ComunityUncheckedCreateWithoutUserInput = {
    id?: number
    name: string
    date_start: Date | string
    followers?: FollowerUncheckedCreateNestedManyWithoutCommunityInput
    foros?: ForoUncheckedCreateNestedManyWithoutComunityInput
  }

  export type ComunityCreateOrConnectWithoutUserInput = {
    where: ComunityWhereUniqueInput
    create: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput>
  }

  export type ComunityCreateManyUserInputEnvelope = {
    data: ComunityCreateManyUserInput | ComunityCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FollowerCreateWithoutUserInput = {
    date: Date | string
    status: boolean
    community?: ComunityCreateNestedOneWithoutFollowersInput
  }

  export type FollowerUncheckedCreateWithoutUserInput = {
    id?: number
    comunityId?: number | null
    date: Date | string
    status: boolean
  }

  export type FollowerCreateOrConnectWithoutUserInput = {
    where: FollowerWhereUniqueInput
    create: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput>
  }

  export type FollowerCreateManyUserInputEnvelope = {
    data: FollowerCreateManyUserInput | FollowerCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type user_line_linkCreateWithoutUserInput = {
    link: LinkCreateNestedOneWithoutUserLineLinkInput
  }

  export type user_line_linkUncheckedCreateWithoutUserInput = {
    id?: number
    linkId: number
  }

  export type user_line_linkCreateOrConnectWithoutUserInput = {
    where: user_line_linkWhereUniqueInput
    create: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput>
  }

  export type user_line_linkCreateManyUserInputEnvelope = {
    data: user_line_linkCreateManyUserInput | user_line_linkCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutUserInput = {
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    category?: CategoryCreateNestedOneWithoutProductsInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutUserInput = {
    id?: number
    categoryId?: number | null
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutUserInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductCreateManyUserInputEnvelope = {
    data: ProductCreateManyUserInput | ProductCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PublicationCreateWithoutUserInput = {
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    customer?: CustomerCreateNestedOneWithoutPublicationsInput
    reactios?: ReactCreateNestedManyWithoutPublicationInput
    comments?: CommentCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutUserInput = {
    id?: number
    customerId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    reactios?: ReactUncheckedCreateNestedManyWithoutPublicationInput
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutUserInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput>
  }

  export type PublicationCreateManyUserInputEnvelope = {
    data: PublicationCreateManyUserInput | PublicationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComunityUpsertWithWhereUniqueWithoutUserInput = {
    where: ComunityWhereUniqueInput
    update: XOR<ComunityUpdateWithoutUserInput, ComunityUncheckedUpdateWithoutUserInput>
    create: XOR<ComunityCreateWithoutUserInput, ComunityUncheckedCreateWithoutUserInput>
  }

  export type ComunityUpdateWithWhereUniqueWithoutUserInput = {
    where: ComunityWhereUniqueInput
    data: XOR<ComunityUpdateWithoutUserInput, ComunityUncheckedUpdateWithoutUserInput>
  }

  export type ComunityUpdateManyWithWhereWithoutUserInput = {
    where: ComunityScalarWhereInput
    data: XOR<ComunityUpdateManyMutationInput, ComunityUncheckedUpdateManyWithoutUserInput>
  }

  export type ComunityScalarWhereInput = {
    AND?: ComunityScalarWhereInput | ComunityScalarWhereInput[]
    OR?: ComunityScalarWhereInput[]
    NOT?: ComunityScalarWhereInput | ComunityScalarWhereInput[]
    id?: IntFilter<"Comunity"> | number
    userId?: IntFilter<"Comunity"> | number
    name?: StringFilter<"Comunity"> | string
    date_start?: DateTimeFilter<"Comunity"> | Date | string
  }

  export type FollowerUpsertWithWhereUniqueWithoutUserInput = {
    where: FollowerWhereUniqueInput
    update: XOR<FollowerUpdateWithoutUserInput, FollowerUncheckedUpdateWithoutUserInput>
    create: XOR<FollowerCreateWithoutUserInput, FollowerUncheckedCreateWithoutUserInput>
  }

  export type FollowerUpdateWithWhereUniqueWithoutUserInput = {
    where: FollowerWhereUniqueInput
    data: XOR<FollowerUpdateWithoutUserInput, FollowerUncheckedUpdateWithoutUserInput>
  }

  export type FollowerUpdateManyWithWhereWithoutUserInput = {
    where: FollowerScalarWhereInput
    data: XOR<FollowerUpdateManyMutationInput, FollowerUncheckedUpdateManyWithoutUserInput>
  }

  export type FollowerScalarWhereInput = {
    AND?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
    OR?: FollowerScalarWhereInput[]
    NOT?: FollowerScalarWhereInput | FollowerScalarWhereInput[]
    id?: IntFilter<"Follower"> | number
    userId?: IntFilter<"Follower"> | number
    comunityId?: IntNullableFilter<"Follower"> | number | null
    date?: DateTimeFilter<"Follower"> | Date | string
    status?: BoolFilter<"Follower"> | boolean
  }

  export type user_line_linkUpsertWithWhereUniqueWithoutUserInput = {
    where: user_line_linkWhereUniqueInput
    update: XOR<user_line_linkUpdateWithoutUserInput, user_line_linkUncheckedUpdateWithoutUserInput>
    create: XOR<user_line_linkCreateWithoutUserInput, user_line_linkUncheckedCreateWithoutUserInput>
  }

  export type user_line_linkUpdateWithWhereUniqueWithoutUserInput = {
    where: user_line_linkWhereUniqueInput
    data: XOR<user_line_linkUpdateWithoutUserInput, user_line_linkUncheckedUpdateWithoutUserInput>
  }

  export type user_line_linkUpdateManyWithWhereWithoutUserInput = {
    where: user_line_linkScalarWhereInput
    data: XOR<user_line_linkUpdateManyMutationInput, user_line_linkUncheckedUpdateManyWithoutUserInput>
  }

  export type user_line_linkScalarWhereInput = {
    AND?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
    OR?: user_line_linkScalarWhereInput[]
    NOT?: user_line_linkScalarWhereInput | user_line_linkScalarWhereInput[]
    id?: IntFilter<"user_line_link"> | number
    linkId?: IntFilter<"user_line_link"> | number
    userId?: IntFilter<"user_line_link"> | number
  }

  export type ProductUpsertWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
    create: XOR<ProductCreateWithoutUserInput, ProductUncheckedCreateWithoutUserInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutUserInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutUserInput, ProductUncheckedUpdateWithoutUserInput>
  }

  export type ProductUpdateManyWithWhereWithoutUserInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutUserInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    userId?: IntFilter<"Product"> | number
    categoryId?: IntNullableFilter<"Product"> | number | null
    serviceid?: IntNullableFilter<"Product"> | number | null
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: StringNullableFilter<"Product"> | string | null
    date_create?: StringNullableFilter<"Product"> | string | null
    status?: BoolNullableFilter<"Product"> | boolean | null
  }

  export type PublicationUpsertWithWhereUniqueWithoutUserInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutUserInput, PublicationUncheckedUpdateWithoutUserInput>
    create: XOR<PublicationCreateWithoutUserInput, PublicationUncheckedCreateWithoutUserInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutUserInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutUserInput, PublicationUncheckedUpdateWithoutUserInput>
  }

  export type PublicationUpdateManyWithWhereWithoutUserInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutUserInput>
  }

  export type PublicationScalarWhereInput = {
    AND?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    OR?: PublicationScalarWhereInput[]
    NOT?: PublicationScalarWhereInput | PublicationScalarWhereInput[]
    id?: IntFilter<"Publication"> | number
    customerId?: IntNullableFilter<"Publication"> | number | null
    userId?: IntNullableFilter<"Publication"> | number | null
    name?: StringFilter<"Publication"> | string
    description?: StringNullableFilter<"Publication"> | string | null
    image?: BytesNullableFilter<"Publication"> | Buffer | null
    date?: DateTimeFilter<"Publication"> | Date | string
    status?: BoolFilter<"Publication"> | boolean
  }

  export type UserCreateWithoutFollowersInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFollowersInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityUncheckedCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFollowersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
  }

  export type ComunityCreateWithoutFollowersInput = {
    name: string
    date_start: Date | string
    user: UserCreateNestedOneWithoutCommunitiesInput
    foros?: ForoCreateNestedManyWithoutComunityInput
  }

  export type ComunityUncheckedCreateWithoutFollowersInput = {
    id?: number
    userId: number
    name: string
    date_start: Date | string
    foros?: ForoUncheckedCreateNestedManyWithoutComunityInput
  }

  export type ComunityCreateOrConnectWithoutFollowersInput = {
    where: ComunityWhereUniqueInput
    create: XOR<ComunityCreateWithoutFollowersInput, ComunityUncheckedCreateWithoutFollowersInput>
  }

  export type UserUpsertWithoutFollowersInput = {
    update: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
    create: XOR<UserCreateWithoutFollowersInput, UserUncheckedCreateWithoutFollowersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFollowersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFollowersInput, UserUncheckedUpdateWithoutFollowersInput>
  }

  export type UserUpdateWithoutFollowersInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUncheckedUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ComunityUpsertWithoutFollowersInput = {
    update: XOR<ComunityUpdateWithoutFollowersInput, ComunityUncheckedUpdateWithoutFollowersInput>
    create: XOR<ComunityCreateWithoutFollowersInput, ComunityUncheckedCreateWithoutFollowersInput>
    where?: ComunityWhereInput
  }

  export type ComunityUpdateToOneWithWhereWithoutFollowersInput = {
    where?: ComunityWhereInput
    data: XOR<ComunityUpdateWithoutFollowersInput, ComunityUncheckedUpdateWithoutFollowersInput>
  }

  export type ComunityUpdateWithoutFollowersInput = {
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunitiesNestedInput
    foros?: ForoUpdateManyWithoutComunityNestedInput
  }

  export type ComunityUncheckedUpdateWithoutFollowersInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    foros?: ForoUncheckedUpdateManyWithoutComunityNestedInput
  }

  export type UserCreateWithoutCommunitiesInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    followers?: FollowerCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommunitiesInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    followers?: FollowerUncheckedCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommunitiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommunitiesInput, UserUncheckedCreateWithoutCommunitiesInput>
  }

  export type FollowerCreateWithoutCommunityInput = {
    date: Date | string
    status: boolean
    user: UserCreateNestedOneWithoutFollowersInput
  }

  export type FollowerUncheckedCreateWithoutCommunityInput = {
    id?: number
    userId: number
    date: Date | string
    status: boolean
  }

  export type FollowerCreateOrConnectWithoutCommunityInput = {
    where: FollowerWhereUniqueInput
    create: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput>
  }

  export type FollowerCreateManyCommunityInputEnvelope = {
    data: FollowerCreateManyCommunityInput | FollowerCreateManyCommunityInput[]
    skipDuplicates?: boolean
  }

  export type ForoCreateWithoutComunityInput = {
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    answers?: AnswerCreateNestedOneWithoutForoInput
    responses?: ResponseCreateNestedOneWithoutForoInput
  }

  export type ForoUncheckedCreateWithoutComunityInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    answers?: AnswerUncheckedCreateNestedOneWithoutForoInput
    responses?: ResponseUncheckedCreateNestedOneWithoutForoInput
  }

  export type ForoCreateOrConnectWithoutComunityInput = {
    where: ForoWhereUniqueInput
    create: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput>
  }

  export type ForoCreateManyComunityInputEnvelope = {
    data: ForoCreateManyComunityInput | ForoCreateManyComunityInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCommunitiesInput = {
    update: XOR<UserUpdateWithoutCommunitiesInput, UserUncheckedUpdateWithoutCommunitiesInput>
    create: XOR<UserCreateWithoutCommunitiesInput, UserUncheckedCreateWithoutCommunitiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommunitiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommunitiesInput, UserUncheckedUpdateWithoutCommunitiesInput>
  }

  export type UserUpdateWithoutCommunitiesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    followers?: FollowerUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommunitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    followers?: FollowerUncheckedUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FollowerUpsertWithWhereUniqueWithoutCommunityInput = {
    where: FollowerWhereUniqueInput
    update: XOR<FollowerUpdateWithoutCommunityInput, FollowerUncheckedUpdateWithoutCommunityInput>
    create: XOR<FollowerCreateWithoutCommunityInput, FollowerUncheckedCreateWithoutCommunityInput>
  }

  export type FollowerUpdateWithWhereUniqueWithoutCommunityInput = {
    where: FollowerWhereUniqueInput
    data: XOR<FollowerUpdateWithoutCommunityInput, FollowerUncheckedUpdateWithoutCommunityInput>
  }

  export type FollowerUpdateManyWithWhereWithoutCommunityInput = {
    where: FollowerScalarWhereInput
    data: XOR<FollowerUpdateManyMutationInput, FollowerUncheckedUpdateManyWithoutCommunityInput>
  }

  export type ForoUpsertWithWhereUniqueWithoutComunityInput = {
    where: ForoWhereUniqueInput
    update: XOR<ForoUpdateWithoutComunityInput, ForoUncheckedUpdateWithoutComunityInput>
    create: XOR<ForoCreateWithoutComunityInput, ForoUncheckedCreateWithoutComunityInput>
  }

  export type ForoUpdateWithWhereUniqueWithoutComunityInput = {
    where: ForoWhereUniqueInput
    data: XOR<ForoUpdateWithoutComunityInput, ForoUncheckedUpdateWithoutComunityInput>
  }

  export type ForoUpdateManyWithWhereWithoutComunityInput = {
    where: ForoScalarWhereInput
    data: XOR<ForoUpdateManyMutationInput, ForoUncheckedUpdateManyWithoutComunityInput>
  }

  export type ForoScalarWhereInput = {
    AND?: ForoScalarWhereInput | ForoScalarWhereInput[]
    OR?: ForoScalarWhereInput[]
    NOT?: ForoScalarWhereInput | ForoScalarWhereInput[]
    id?: IntFilter<"Foro"> | number
    subject?: StringNullableFilter<"Foro"> | string | null
    description?: StringFilter<"Foro"> | string
    date_publication?: DateTimeNullableFilter<"Foro"> | Date | string | null
    date_update?: DateTimeNullableFilter<"Foro"> | Date | string | null
    comunityId?: IntFilter<"Foro"> | number
  }

  export type AnswerCreateWithoutForoInput = {
    message?: string | null
    responses?: ResponseCreateNestedManyWithoutAnswerInput
  }

  export type AnswerUncheckedCreateWithoutForoInput = {
    id?: number
    message?: string | null
    responses?: ResponseUncheckedCreateNestedManyWithoutAnswerInput
  }

  export type AnswerCreateOrConnectWithoutForoInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
  }

  export type ResponseCreateWithoutForoInput = {
    message?: string | null
    answer: AnswerCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutForoInput = {
    id?: number
    message?: string | null
    answerId: number
  }

  export type ResponseCreateOrConnectWithoutForoInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
  }

  export type ComunityCreateWithoutForosInput = {
    name: string
    date_start: Date | string
    user: UserCreateNestedOneWithoutCommunitiesInput
    followers?: FollowerCreateNestedManyWithoutCommunityInput
  }

  export type ComunityUncheckedCreateWithoutForosInput = {
    id?: number
    userId: number
    name: string
    date_start: Date | string
    followers?: FollowerUncheckedCreateNestedManyWithoutCommunityInput
  }

  export type ComunityCreateOrConnectWithoutForosInput = {
    where: ComunityWhereUniqueInput
    create: XOR<ComunityCreateWithoutForosInput, ComunityUncheckedCreateWithoutForosInput>
  }

  export type AnswerUpsertWithoutForoInput = {
    update: XOR<AnswerUpdateWithoutForoInput, AnswerUncheckedUpdateWithoutForoInput>
    create: XOR<AnswerCreateWithoutForoInput, AnswerUncheckedCreateWithoutForoInput>
    where?: AnswerWhereInput
  }

  export type AnswerUpdateToOneWithWhereWithoutForoInput = {
    where?: AnswerWhereInput
    data: XOR<AnswerUpdateWithoutForoInput, AnswerUncheckedUpdateWithoutForoInput>
  }

  export type AnswerUpdateWithoutForoInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUpdateManyWithoutAnswerNestedInput
  }

  export type AnswerUncheckedUpdateWithoutForoInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responses?: ResponseUncheckedUpdateManyWithoutAnswerNestedInput
  }

  export type ResponseUpsertWithoutForoInput = {
    update: XOR<ResponseUpdateWithoutForoInput, ResponseUncheckedUpdateWithoutForoInput>
    create: XOR<ResponseCreateWithoutForoInput, ResponseUncheckedCreateWithoutForoInput>
    where?: ResponseWhereInput
  }

  export type ResponseUpdateToOneWithWhereWithoutForoInput = {
    where?: ResponseWhereInput
    data: XOR<ResponseUpdateWithoutForoInput, ResponseUncheckedUpdateWithoutForoInput>
  }

  export type ResponseUpdateWithoutForoInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    answer?: AnswerUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutForoInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    answerId?: IntFieldUpdateOperationsInput | number
  }

  export type ComunityUpsertWithoutForosInput = {
    update: XOR<ComunityUpdateWithoutForosInput, ComunityUncheckedUpdateWithoutForosInput>
    create: XOR<ComunityCreateWithoutForosInput, ComunityUncheckedCreateWithoutForosInput>
    where?: ComunityWhereInput
  }

  export type ComunityUpdateToOneWithWhereWithoutForosInput = {
    where?: ComunityWhereInput
    data: XOR<ComunityUpdateWithoutForosInput, ComunityUncheckedUpdateWithoutForosInput>
  }

  export type ComunityUpdateWithoutForosInput = {
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCommunitiesNestedInput
    followers?: FollowerUpdateManyWithoutCommunityNestedInput
  }

  export type ComunityUncheckedUpdateWithoutForosInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: FollowerUncheckedUpdateManyWithoutCommunityNestedInput
  }

  export type ForoCreateWithoutAnswersInput = {
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    responses?: ResponseCreateNestedOneWithoutForoInput
    comunity: ComunityCreateNestedOneWithoutForosInput
  }

  export type ForoUncheckedCreateWithoutAnswersInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    comunityId: number
    responses?: ResponseUncheckedCreateNestedOneWithoutForoInput
  }

  export type ForoCreateOrConnectWithoutAnswersInput = {
    where: ForoWhereUniqueInput
    create: XOR<ForoCreateWithoutAnswersInput, ForoUncheckedCreateWithoutAnswersInput>
  }

  export type ResponseCreateWithoutAnswerInput = {
    message?: string | null
    foro: ForoCreateNestedOneWithoutResponsesInput
  }

  export type ResponseUncheckedCreateWithoutAnswerInput = {
    id?: number
    message?: string | null
    foroId: number
  }

  export type ResponseCreateOrConnectWithoutAnswerInput = {
    where: ResponseWhereUniqueInput
    create: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput>
  }

  export type ResponseCreateManyAnswerInputEnvelope = {
    data: ResponseCreateManyAnswerInput | ResponseCreateManyAnswerInput[]
    skipDuplicates?: boolean
  }

  export type ForoUpsertWithoutAnswersInput = {
    update: XOR<ForoUpdateWithoutAnswersInput, ForoUncheckedUpdateWithoutAnswersInput>
    create: XOR<ForoCreateWithoutAnswersInput, ForoUncheckedCreateWithoutAnswersInput>
    where?: ForoWhereInput
  }

  export type ForoUpdateToOneWithWhereWithoutAnswersInput = {
    where?: ForoWhereInput
    data: XOR<ForoUpdateWithoutAnswersInput, ForoUncheckedUpdateWithoutAnswersInput>
  }

  export type ForoUpdateWithoutAnswersInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    responses?: ResponseUpdateOneWithoutForoNestedInput
    comunity?: ComunityUpdateOneRequiredWithoutForosNestedInput
  }

  export type ForoUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comunityId?: IntFieldUpdateOperationsInput | number
    responses?: ResponseUncheckedUpdateOneWithoutForoNestedInput
  }

  export type ResponseUpsertWithWhereUniqueWithoutAnswerInput = {
    where: ResponseWhereUniqueInput
    update: XOR<ResponseUpdateWithoutAnswerInput, ResponseUncheckedUpdateWithoutAnswerInput>
    create: XOR<ResponseCreateWithoutAnswerInput, ResponseUncheckedCreateWithoutAnswerInput>
  }

  export type ResponseUpdateWithWhereUniqueWithoutAnswerInput = {
    where: ResponseWhereUniqueInput
    data: XOR<ResponseUpdateWithoutAnswerInput, ResponseUncheckedUpdateWithoutAnswerInput>
  }

  export type ResponseUpdateManyWithWhereWithoutAnswerInput = {
    where: ResponseScalarWhereInput
    data: XOR<ResponseUpdateManyMutationInput, ResponseUncheckedUpdateManyWithoutAnswerInput>
  }

  export type ResponseScalarWhereInput = {
    AND?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    OR?: ResponseScalarWhereInput[]
    NOT?: ResponseScalarWhereInput | ResponseScalarWhereInput[]
    id?: IntFilter<"Response"> | number
    message?: StringNullableFilter<"Response"> | string | null
    foroId?: IntFilter<"Response"> | number
    answerId?: IntFilter<"Response"> | number
  }

  export type ForoCreateWithoutResponsesInput = {
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    answers?: AnswerCreateNestedOneWithoutForoInput
    comunity: ComunityCreateNestedOneWithoutForosInput
  }

  export type ForoUncheckedCreateWithoutResponsesInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
    comunityId: number
    answers?: AnswerUncheckedCreateNestedOneWithoutForoInput
  }

  export type ForoCreateOrConnectWithoutResponsesInput = {
    where: ForoWhereUniqueInput
    create: XOR<ForoCreateWithoutResponsesInput, ForoUncheckedCreateWithoutResponsesInput>
  }

  export type AnswerCreateWithoutResponsesInput = {
    message?: string | null
    foro: ForoCreateNestedOneWithoutAnswersInput
  }

  export type AnswerUncheckedCreateWithoutResponsesInput = {
    id?: number
    message?: string | null
    foroId: number
  }

  export type AnswerCreateOrConnectWithoutResponsesInput = {
    where: AnswerWhereUniqueInput
    create: XOR<AnswerCreateWithoutResponsesInput, AnswerUncheckedCreateWithoutResponsesInput>
  }

  export type ForoUpsertWithoutResponsesInput = {
    update: XOR<ForoUpdateWithoutResponsesInput, ForoUncheckedUpdateWithoutResponsesInput>
    create: XOR<ForoCreateWithoutResponsesInput, ForoUncheckedCreateWithoutResponsesInput>
    where?: ForoWhereInput
  }

  export type ForoUpdateToOneWithWhereWithoutResponsesInput = {
    where?: ForoWhereInput
    data: XOR<ForoUpdateWithoutResponsesInput, ForoUncheckedUpdateWithoutResponsesInput>
  }

  export type ForoUpdateWithoutResponsesInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUpdateOneWithoutForoNestedInput
    comunity?: ComunityUpdateOneRequiredWithoutForosNestedInput
  }

  export type ForoUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    comunityId?: IntFieldUpdateOperationsInput | number
    answers?: AnswerUncheckedUpdateOneWithoutForoNestedInput
  }

  export type AnswerUpsertWithoutResponsesInput = {
    update: XOR<AnswerUpdateWithoutResponsesInput, AnswerUncheckedUpdateWithoutResponsesInput>
    create: XOR<AnswerCreateWithoutResponsesInput, AnswerUncheckedCreateWithoutResponsesInput>
    where?: AnswerWhereInput
  }

  export type AnswerUpdateToOneWithWhereWithoutResponsesInput = {
    where?: AnswerWhereInput
    data: XOR<AnswerUpdateWithoutResponsesInput, AnswerUncheckedUpdateWithoutResponsesInput>
  }

  export type AnswerUpdateWithoutResponsesInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foro?: ForoUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type AnswerUncheckedUpdateWithoutResponsesInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
  }

  export type LinkCreateWithoutRolInput = {
    name: string
    Link: string
    userLineLink?: user_line_linkCreateNestedManyWithoutLinkInput
  }

  export type LinkUncheckedCreateWithoutRolInput = {
    id?: number
    name: string
    Link: string
    userLineLink?: user_line_linkUncheckedCreateNestedManyWithoutLinkInput
  }

  export type LinkCreateOrConnectWithoutRolInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput>
  }

  export type LinkCreateManyRolInputEnvelope = {
    data: LinkCreateManyRolInput | LinkCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type LinkUpsertWithWhereUniqueWithoutRolInput = {
    where: LinkWhereUniqueInput
    update: XOR<LinkUpdateWithoutRolInput, LinkUncheckedUpdateWithoutRolInput>
    create: XOR<LinkCreateWithoutRolInput, LinkUncheckedCreateWithoutRolInput>
  }

  export type LinkUpdateWithWhereUniqueWithoutRolInput = {
    where: LinkWhereUniqueInput
    data: XOR<LinkUpdateWithoutRolInput, LinkUncheckedUpdateWithoutRolInput>
  }

  export type LinkUpdateManyWithWhereWithoutRolInput = {
    where: LinkScalarWhereInput
    data: XOR<LinkUpdateManyMutationInput, LinkUncheckedUpdateManyWithoutRolInput>
  }

  export type LinkScalarWhereInput = {
    AND?: LinkScalarWhereInput | LinkScalarWhereInput[]
    OR?: LinkScalarWhereInput[]
    NOT?: LinkScalarWhereInput | LinkScalarWhereInput[]
    id?: IntFilter<"Link"> | number
    rolId?: IntFilter<"Link"> | number
    name?: StringFilter<"Link"> | string
    Link?: StringFilter<"Link"> | string
  }

  export type RolCreateWithoutLinksInput = {
    name: string
  }

  export type RolUncheckedCreateWithoutLinksInput = {
    id?: number
    name: string
  }

  export type RolCreateOrConnectWithoutLinksInput = {
    where: RolWhereUniqueInput
    create: XOR<RolCreateWithoutLinksInput, RolUncheckedCreateWithoutLinksInput>
  }

  export type user_line_linkCreateWithoutLinkInput = {
    user: UserCreateNestedOneWithoutUser_line_linkInput
  }

  export type user_line_linkUncheckedCreateWithoutLinkInput = {
    id?: number
    userId: number
  }

  export type user_line_linkCreateOrConnectWithoutLinkInput = {
    where: user_line_linkWhereUniqueInput
    create: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput>
  }

  export type user_line_linkCreateManyLinkInputEnvelope = {
    data: user_line_linkCreateManyLinkInput | user_line_linkCreateManyLinkInput[]
    skipDuplicates?: boolean
  }

  export type RolUpsertWithoutLinksInput = {
    update: XOR<RolUpdateWithoutLinksInput, RolUncheckedUpdateWithoutLinksInput>
    create: XOR<RolCreateWithoutLinksInput, RolUncheckedCreateWithoutLinksInput>
    where?: RolWhereInput
  }

  export type RolUpdateToOneWithWhereWithoutLinksInput = {
    where?: RolWhereInput
    data: XOR<RolUpdateWithoutLinksInput, RolUncheckedUpdateWithoutLinksInput>
  }

  export type RolUpdateWithoutLinksInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RolUncheckedUpdateWithoutLinksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type user_line_linkUpsertWithWhereUniqueWithoutLinkInput = {
    where: user_line_linkWhereUniqueInput
    update: XOR<user_line_linkUpdateWithoutLinkInput, user_line_linkUncheckedUpdateWithoutLinkInput>
    create: XOR<user_line_linkCreateWithoutLinkInput, user_line_linkUncheckedCreateWithoutLinkInput>
  }

  export type user_line_linkUpdateWithWhereUniqueWithoutLinkInput = {
    where: user_line_linkWhereUniqueInput
    data: XOR<user_line_linkUpdateWithoutLinkInput, user_line_linkUncheckedUpdateWithoutLinkInput>
  }

  export type user_line_linkUpdateManyWithWhereWithoutLinkInput = {
    where: user_line_linkScalarWhereInput
    data: XOR<user_line_linkUpdateManyMutationInput, user_line_linkUncheckedUpdateManyWithoutLinkInput>
  }

  export type LinkCreateWithoutUserLineLinkInput = {
    name: string
    Link: string
    rol: RolCreateNestedOneWithoutLinksInput
  }

  export type LinkUncheckedCreateWithoutUserLineLinkInput = {
    id?: number
    rolId: number
    name: string
    Link: string
  }

  export type LinkCreateOrConnectWithoutUserLineLinkInput = {
    where: LinkWhereUniqueInput
    create: XOR<LinkCreateWithoutUserLineLinkInput, LinkUncheckedCreateWithoutUserLineLinkInput>
  }

  export type UserCreateWithoutUser_line_linkInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityCreateNestedManyWithoutUserInput
    followers?: FollowerCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_line_linkInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowerUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_line_linkInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_line_linkInput, UserUncheckedCreateWithoutUser_line_linkInput>
  }

  export type LinkUpsertWithoutUserLineLinkInput = {
    update: XOR<LinkUpdateWithoutUserLineLinkInput, LinkUncheckedUpdateWithoutUserLineLinkInput>
    create: XOR<LinkCreateWithoutUserLineLinkInput, LinkUncheckedCreateWithoutUserLineLinkInput>
    where?: LinkWhereInput
  }

  export type LinkUpdateToOneWithWhereWithoutUserLineLinkInput = {
    where?: LinkWhereInput
    data: XOR<LinkUpdateWithoutUserLineLinkInput, LinkUncheckedUpdateWithoutUserLineLinkInput>
  }

  export type LinkUpdateWithoutUserLineLinkInput = {
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
    rol?: RolUpdateOneRequiredWithoutLinksNestedInput
  }

  export type LinkUncheckedUpdateWithoutUserLineLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    rolId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutUser_line_linkInput = {
    update: XOR<UserUpdateWithoutUser_line_linkInput, UserUncheckedUpdateWithoutUser_line_linkInput>
    create: XOR<UserCreateWithoutUser_line_linkInput, UserUncheckedCreateWithoutUser_line_linkInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_line_linkInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_line_linkInput, UserUncheckedUpdateWithoutUser_line_linkInput>
  }

  export type UserUpdateWithoutUser_line_linkInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUpdateManyWithoutUserNestedInput
    followers?: FollowerUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_line_linkInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowerUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ProductCreateWithoutCategoryInput = {
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    user: UserCreateNestedOneWithoutProductsInput
    service?: ServiceCreateNestedOneWithoutProductsInput
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutCategoryInput = {
    id?: number
    userId: number
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductCreateManyCategoryInputEnvelope = {
    data: ProductCreateManyCategoryInput | ProductCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
    create: XOR<ProductCreateWithoutCategoryInput, ProductUncheckedCreateWithoutCategoryInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutCategoryInput, ProductUncheckedUpdateWithoutCategoryInput>
  }

  export type ProductUpdateManyWithWhereWithoutCategoryInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ProductCreateWithoutServiceInput = {
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    user: UserCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutServiceInput = {
    id?: number
    userId: number
    categoryId?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutServiceInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductCreateManyServiceInputEnvelope = {
    data: ProductCreateManyServiceInput | ProductCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
    create: XOR<ProductCreateWithoutServiceInput, ProductUncheckedCreateWithoutServiceInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutServiceInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutServiceInput, ProductUncheckedUpdateWithoutServiceInput>
  }

  export type ProductUpdateManyWithWhereWithoutServiceInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutServiceInput>
  }

  export type UserCreateWithoutProductsInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityCreateNestedManyWithoutUserInput
    followers?: FollowerCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkCreateNestedManyWithoutUserInput
    publications?: PublicationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProductsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowerUncheckedCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkUncheckedCreateNestedManyWithoutUserInput
    publications?: PublicationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProductsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
  }

  export type CategoryCreateWithoutProductsInput = {
    name: string
    description?: string | null
  }

  export type CategoryUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    description?: string | null
  }

  export type CategoryCreateOrConnectWithoutProductsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
  }

  export type ServiceCreateWithoutProductsInput = {
    name: string
    DATE_START?: Date | string | null
    DATE_END?: Date | string | null
  }

  export type ServiceUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    DATE_START?: Date | string | null
    DATE_END?: Date | string | null
  }

  export type ServiceCreateOrConnectWithoutProductsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
  }

  export type Inv_Line_ProCreateWithoutProductInput = {
    invoice: InvoiceCreateNestedOneWithoutInv_line_prosInput
  }

  export type Inv_Line_ProUncheckedCreateWithoutProductInput = {
    id?: number
    invoiceId: number
  }

  export type Inv_Line_ProCreateOrConnectWithoutProductInput = {
    where: Inv_Line_ProWhereUniqueInput
    create: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput>
  }

  export type Inv_Line_ProCreateManyProductInputEnvelope = {
    data: Inv_Line_ProCreateManyProductInput | Inv_Line_ProCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProductsInput = {
    update: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
    create: XOR<UserCreateWithoutProductsInput, UserUncheckedCreateWithoutProductsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProductsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProductsInput, UserUncheckedUpdateWithoutProductsInput>
  }

  export type UserUpdateWithoutProductsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUpdateManyWithoutUserNestedInput
    followers?: FollowerUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUpdateManyWithoutUserNestedInput
    publications?: PublicationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowerUncheckedUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUncheckedUpdateManyWithoutUserNestedInput
    publications?: PublicationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CategoryUpsertWithoutProductsInput = {
    update: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
    create: XOR<CategoryCreateWithoutProductsInput, CategoryUncheckedCreateWithoutProductsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutProductsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutProductsInput, CategoryUncheckedUpdateWithoutProductsInput>
  }

  export type CategoryUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceUpsertWithoutProductsInput = {
    update: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
    create: XOR<ServiceCreateWithoutProductsInput, ServiceUncheckedCreateWithoutProductsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutProductsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutProductsInput, ServiceUncheckedUpdateWithoutProductsInput>
  }

  export type ServiceUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ServiceUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    DATE_START?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATE_END?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type Inv_Line_ProUpsertWithWhereUniqueWithoutProductInput = {
    where: Inv_Line_ProWhereUniqueInput
    update: XOR<Inv_Line_ProUpdateWithoutProductInput, Inv_Line_ProUncheckedUpdateWithoutProductInput>
    create: XOR<Inv_Line_ProCreateWithoutProductInput, Inv_Line_ProUncheckedCreateWithoutProductInput>
  }

  export type Inv_Line_ProUpdateWithWhereUniqueWithoutProductInput = {
    where: Inv_Line_ProWhereUniqueInput
    data: XOR<Inv_Line_ProUpdateWithoutProductInput, Inv_Line_ProUncheckedUpdateWithoutProductInput>
  }

  export type Inv_Line_ProUpdateManyWithWhereWithoutProductInput = {
    where: Inv_Line_ProScalarWhereInput
    data: XOR<Inv_Line_ProUpdateManyMutationInput, Inv_Line_ProUncheckedUpdateManyWithoutProductInput>
  }

  export type Inv_Line_ProScalarWhereInput = {
    AND?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
    OR?: Inv_Line_ProScalarWhereInput[]
    NOT?: Inv_Line_ProScalarWhereInput | Inv_Line_ProScalarWhereInput[]
    id?: IntFilter<"Inv_Line_Pro"> | number
    productId?: IntFilter<"Inv_Line_Pro"> | number
    invoiceId?: IntFilter<"Inv_Line_Pro"> | number
  }

  export type InvoiceCreateWithoutCustomerInput = {
    date: Date | string
    inv_line_pros?: Inv_Line_ProCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutCustomerInput = {
    id?: number
    date: Date | string
    inv_line_pros?: Inv_Line_ProUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceCreateManyCustomerInputEnvelope = {
    data: InvoiceCreateManyCustomerInput | InvoiceCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type PublicationCreateWithoutCustomerInput = {
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    user?: UserCreateNestedOneWithoutPublicationsInput
    reactios?: ReactCreateNestedManyWithoutPublicationInput
    comments?: CommentCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutCustomerInput = {
    id?: number
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    reactios?: ReactUncheckedCreateNestedManyWithoutPublicationInput
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutCustomerInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput>
  }

  export type PublicationCreateManyCustomerInputEnvelope = {
    data: PublicationCreateManyCustomerInput | PublicationCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceUpsertWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
    create: XOR<InvoiceCreateWithoutCustomerInput, InvoiceUncheckedCreateWithoutCustomerInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutCustomerInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutCustomerInput, InvoiceUncheckedUpdateWithoutCustomerInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutCustomerInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutCustomerInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: IntFilter<"Invoice"> | number
    customerId?: IntFilter<"Invoice"> | number
    date?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PublicationUpsertWithWhereUniqueWithoutCustomerInput = {
    where: PublicationWhereUniqueInput
    update: XOR<PublicationUpdateWithoutCustomerInput, PublicationUncheckedUpdateWithoutCustomerInput>
    create: XOR<PublicationCreateWithoutCustomerInput, PublicationUncheckedCreateWithoutCustomerInput>
  }

  export type PublicationUpdateWithWhereUniqueWithoutCustomerInput = {
    where: PublicationWhereUniqueInput
    data: XOR<PublicationUpdateWithoutCustomerInput, PublicationUncheckedUpdateWithoutCustomerInput>
  }

  export type PublicationUpdateManyWithWhereWithoutCustomerInput = {
    where: PublicationScalarWhereInput
    data: XOR<PublicationUpdateManyMutationInput, PublicationUncheckedUpdateManyWithoutCustomerInput>
  }

  export type CustomerCreateWithoutInvicesInput = {
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    publications?: PublicationCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutInvicesInput = {
    id?: number
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    publications?: PublicationUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutInvicesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutInvicesInput, CustomerUncheckedCreateWithoutInvicesInput>
  }

  export type Inv_Line_ProCreateWithoutInvoiceInput = {
    product: ProductCreateNestedOneWithoutInv_line_prosInput
  }

  export type Inv_Line_ProUncheckedCreateWithoutInvoiceInput = {
    id?: number
    productId: number
  }

  export type Inv_Line_ProCreateOrConnectWithoutInvoiceInput = {
    where: Inv_Line_ProWhereUniqueInput
    create: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput>
  }

  export type Inv_Line_ProCreateManyInvoiceInputEnvelope = {
    data: Inv_Line_ProCreateManyInvoiceInput | Inv_Line_ProCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutInvicesInput = {
    update: XOR<CustomerUpdateWithoutInvicesInput, CustomerUncheckedUpdateWithoutInvicesInput>
    create: XOR<CustomerCreateWithoutInvicesInput, CustomerUncheckedCreateWithoutInvicesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutInvicesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutInvicesInput, CustomerUncheckedUpdateWithoutInvicesInput>
  }

  export type CustomerUpdateWithoutInvicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    publications?: PublicationUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutInvicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    publications?: PublicationUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type Inv_Line_ProUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: Inv_Line_ProWhereUniqueInput
    update: XOR<Inv_Line_ProUpdateWithoutInvoiceInput, Inv_Line_ProUncheckedUpdateWithoutInvoiceInput>
    create: XOR<Inv_Line_ProCreateWithoutInvoiceInput, Inv_Line_ProUncheckedCreateWithoutInvoiceInput>
  }

  export type Inv_Line_ProUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: Inv_Line_ProWhereUniqueInput
    data: XOR<Inv_Line_ProUpdateWithoutInvoiceInput, Inv_Line_ProUncheckedUpdateWithoutInvoiceInput>
  }

  export type Inv_Line_ProUpdateManyWithWhereWithoutInvoiceInput = {
    where: Inv_Line_ProScalarWhereInput
    data: XOR<Inv_Line_ProUpdateManyMutationInput, Inv_Line_ProUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type ProductCreateWithoutInv_line_prosInput = {
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
    user: UserCreateNestedOneWithoutProductsInput
    category?: CategoryCreateNestedOneWithoutProductsInput
    service?: ServiceCreateNestedOneWithoutProductsInput
  }

  export type ProductUncheckedCreateWithoutInv_line_prosInput = {
    id?: number
    userId: number
    categoryId?: number | null
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
  }

  export type ProductCreateOrConnectWithoutInv_line_prosInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutInv_line_prosInput, ProductUncheckedCreateWithoutInv_line_prosInput>
  }

  export type InvoiceCreateWithoutInv_line_prosInput = {
    date: Date | string
    customer: CustomerCreateNestedOneWithoutInvicesInput
  }

  export type InvoiceUncheckedCreateWithoutInv_line_prosInput = {
    id?: number
    customerId: number
    date: Date | string
  }

  export type InvoiceCreateOrConnectWithoutInv_line_prosInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutInv_line_prosInput, InvoiceUncheckedCreateWithoutInv_line_prosInput>
  }

  export type ProductUpsertWithoutInv_line_prosInput = {
    update: XOR<ProductUpdateWithoutInv_line_prosInput, ProductUncheckedUpdateWithoutInv_line_prosInput>
    create: XOR<ProductCreateWithoutInv_line_prosInput, ProductUncheckedCreateWithoutInv_line_prosInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutInv_line_prosInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutInv_line_prosInput, ProductUncheckedUpdateWithoutInv_line_prosInput>
  }

  export type ProductUpdateWithoutInv_line_prosInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
  }

  export type ProductUncheckedUpdateWithoutInv_line_prosInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type InvoiceUpsertWithoutInv_line_prosInput = {
    update: XOR<InvoiceUpdateWithoutInv_line_prosInput, InvoiceUncheckedUpdateWithoutInv_line_prosInput>
    create: XOR<InvoiceCreateWithoutInv_line_prosInput, InvoiceUncheckedCreateWithoutInv_line_prosInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutInv_line_prosInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutInv_line_prosInput, InvoiceUncheckedUpdateWithoutInv_line_prosInput>
  }

  export type InvoiceUpdateWithoutInv_line_prosInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutInvicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutInv_line_prosInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerCreateWithoutPublicationsInput = {
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    invices?: InvoiceCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutPublicationsInput = {
    id?: number
    email: string
    password: string
    name: string
    lname: string
    phone: string
    idCard: string
    Company: string
    city?: string | null
    job: string
    invices?: InvoiceUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutPublicationsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutPublicationsInput, CustomerUncheckedCreateWithoutPublicationsInput>
  }

  export type UserCreateWithoutPublicationsInput = {
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityCreateNestedManyWithoutUserInput
    followers?: FollowerCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkCreateNestedManyWithoutUserInput
    products?: ProductCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPublicationsInput = {
    id?: number
    email: string
    password: string
    name?: string | null
    lname: string
    phone: string
    idCard: string
    semestre: number
    status: boolean
    alias?: string | null
    biography: string
    communities?: ComunityUncheckedCreateNestedManyWithoutUserInput
    followers?: FollowerUncheckedCreateNestedManyWithoutUserInput
    user_line_link?: user_line_linkUncheckedCreateNestedManyWithoutUserInput
    products?: ProductUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPublicationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
  }

  export type ReactCreateWithoutPublicationInput = {
    name: string
  }

  export type ReactUncheckedCreateWithoutPublicationInput = {
    id?: number
    name: string
  }

  export type ReactCreateOrConnectWithoutPublicationInput = {
    where: ReactWhereUniqueInput
    create: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput>
  }

  export type ReactCreateManyPublicationInputEnvelope = {
    data: ReactCreateManyPublicationInput | ReactCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutPublicationInput = {
    text: string
  }

  export type CommentUncheckedCreateWithoutPublicationInput = {
    id?: number
    text: string
  }

  export type CommentCreateOrConnectWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput>
  }

  export type CommentCreateManyPublicationInputEnvelope = {
    data: CommentCreateManyPublicationInput | CommentCreateManyPublicationInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithoutPublicationsInput = {
    update: XOR<CustomerUpdateWithoutPublicationsInput, CustomerUncheckedUpdateWithoutPublicationsInput>
    create: XOR<CustomerCreateWithoutPublicationsInput, CustomerUncheckedCreateWithoutPublicationsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutPublicationsInput, CustomerUncheckedUpdateWithoutPublicationsInput>
  }

  export type CustomerUpdateWithoutPublicationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    invices?: InvoiceUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutPublicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    Company?: StringFieldUpdateOperationsInput | string
    city?: NullableStringFieldUpdateOperationsInput | string | null
    job?: StringFieldUpdateOperationsInput | string
    invices?: InvoiceUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutPublicationsInput = {
    update: XOR<UserUpdateWithoutPublicationsInput, UserUncheckedUpdateWithoutPublicationsInput>
    create: XOR<UserCreateWithoutPublicationsInput, UserUncheckedCreateWithoutPublicationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPublicationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPublicationsInput, UserUncheckedUpdateWithoutPublicationsInput>
  }

  export type UserUpdateWithoutPublicationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUpdateManyWithoutUserNestedInput
    followers?: FollowerUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUpdateManyWithoutUserNestedInput
    products?: ProductUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPublicationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    lname?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    idCard?: StringFieldUpdateOperationsInput | string
    semestre?: IntFieldUpdateOperationsInput | number
    status?: BoolFieldUpdateOperationsInput | boolean
    alias?: NullableStringFieldUpdateOperationsInput | string | null
    biography?: StringFieldUpdateOperationsInput | string
    communities?: ComunityUncheckedUpdateManyWithoutUserNestedInput
    followers?: FollowerUncheckedUpdateManyWithoutUserNestedInput
    user_line_link?: user_line_linkUncheckedUpdateManyWithoutUserNestedInput
    products?: ProductUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReactUpsertWithWhereUniqueWithoutPublicationInput = {
    where: ReactWhereUniqueInput
    update: XOR<ReactUpdateWithoutPublicationInput, ReactUncheckedUpdateWithoutPublicationInput>
    create: XOR<ReactCreateWithoutPublicationInput, ReactUncheckedCreateWithoutPublicationInput>
  }

  export type ReactUpdateWithWhereUniqueWithoutPublicationInput = {
    where: ReactWhereUniqueInput
    data: XOR<ReactUpdateWithoutPublicationInput, ReactUncheckedUpdateWithoutPublicationInput>
  }

  export type ReactUpdateManyWithWhereWithoutPublicationInput = {
    where: ReactScalarWhereInput
    data: XOR<ReactUpdateManyMutationInput, ReactUncheckedUpdateManyWithoutPublicationInput>
  }

  export type ReactScalarWhereInput = {
    AND?: ReactScalarWhereInput | ReactScalarWhereInput[]
    OR?: ReactScalarWhereInput[]
    NOT?: ReactScalarWhereInput | ReactScalarWhereInput[]
    id?: IntFilter<"React"> | number
    publicationId?: IntFilter<"React"> | number
    name?: StringFilter<"React"> | string
  }

  export type CommentUpsertWithWhereUniqueWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPublicationInput, CommentUncheckedUpdateWithoutPublicationInput>
    create: XOR<CommentCreateWithoutPublicationInput, CommentUncheckedCreateWithoutPublicationInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPublicationInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPublicationInput, CommentUncheckedUpdateWithoutPublicationInput>
  }

  export type CommentUpdateManyWithWhereWithoutPublicationInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPublicationInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: IntFilter<"Comment"> | number
    publicationId?: IntFilter<"Comment"> | number
    text?: StringFilter<"Comment"> | string
  }

  export type PublicationCreateWithoutReactiosInput = {
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    customer?: CustomerCreateNestedOneWithoutPublicationsInput
    user?: UserCreateNestedOneWithoutPublicationsInput
    comments?: CommentCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutReactiosInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    comments?: CommentUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutReactiosInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutReactiosInput, PublicationUncheckedCreateWithoutReactiosInput>
  }

  export type PublicationUpsertWithoutReactiosInput = {
    update: XOR<PublicationUpdateWithoutReactiosInput, PublicationUncheckedUpdateWithoutReactiosInput>
    create: XOR<PublicationCreateWithoutReactiosInput, PublicationUncheckedCreateWithoutReactiosInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutReactiosInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutReactiosInput, PublicationUncheckedUpdateWithoutReactiosInput>
  }

  export type PublicationUpdateWithoutReactiosInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutPublicationsNestedInput
    user?: UserUpdateOneWithoutPublicationsNestedInput
    comments?: CommentUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutReactiosInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationCreateWithoutCommentsInput = {
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    customer?: CustomerCreateNestedOneWithoutPublicationsInput
    user?: UserCreateNestedOneWithoutPublicationsInput
    reactios?: ReactCreateNestedManyWithoutPublicationInput
  }

  export type PublicationUncheckedCreateWithoutCommentsInput = {
    id?: number
    customerId?: number | null
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
    reactios?: ReactUncheckedCreateNestedManyWithoutPublicationInput
  }

  export type PublicationCreateOrConnectWithoutCommentsInput = {
    where: PublicationWhereUniqueInput
    create: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
  }

  export type PublicationUpsertWithoutCommentsInput = {
    update: XOR<PublicationUpdateWithoutCommentsInput, PublicationUncheckedUpdateWithoutCommentsInput>
    create: XOR<PublicationCreateWithoutCommentsInput, PublicationUncheckedCreateWithoutCommentsInput>
    where?: PublicationWhereInput
  }

  export type PublicationUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PublicationWhereInput
    data: XOR<PublicationUpdateWithoutCommentsInput, PublicationUncheckedUpdateWithoutCommentsInput>
  }

  export type PublicationUpdateWithoutCommentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutPublicationsNestedInput
    user?: UserUpdateOneWithoutPublicationsNestedInput
    reactios?: ReactUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reactios?: ReactUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type ComunityCreateManyUserInput = {
    id?: number
    name: string
    date_start: Date | string
  }

  export type FollowerCreateManyUserInput = {
    id?: number
    comunityId?: number | null
    date: Date | string
    status: boolean
  }

  export type user_line_linkCreateManyUserInput = {
    id?: number
    linkId: number
  }

  export type ProductCreateManyUserInput = {
    id?: number
    categoryId?: number | null
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
  }

  export type PublicationCreateManyUserInput = {
    id?: number
    customerId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
  }

  export type ComunityUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: FollowerUpdateManyWithoutCommunityNestedInput
    foros?: ForoUpdateManyWithoutComunityNestedInput
  }

  export type ComunityUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
    followers?: FollowerUncheckedUpdateManyWithoutCommunityNestedInput
    foros?: ForoUncheckedUpdateManyWithoutComunityNestedInput
  }

  export type ComunityUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    date_start?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowerUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    community?: ComunityUpdateOneWithoutFollowersNestedInput
  }

  export type FollowerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comunityId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowerUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    comunityId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_line_linkUpdateWithoutUserInput = {
    link?: LinkUpdateOneRequiredWithoutUserLineLinkNestedInput
  }

  export type user_line_linkUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    linkId?: IntFieldUpdateOperationsInput | number
  }

  export type user_line_linkUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    linkId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    category?: CategoryUpdateOneWithoutProductsNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type PublicationUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    customer?: CustomerUpdateOneWithoutPublicationsNestedInput
    reactios?: ReactUpdateManyWithoutPublicationNestedInput
    comments?: CommentUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reactios?: ReactUncheckedUpdateManyWithoutPublicationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowerCreateManyCommunityInput = {
    id?: number
    userId: number
    date: Date | string
    status: boolean
  }

  export type ForoCreateManyComunityInput = {
    id?: number
    subject?: string | null
    description: string
    date_publication?: Date | string | null
    date_update?: Date | string | null
  }

  export type FollowerUpdateWithoutCommunityInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneRequiredWithoutFollowersNestedInput
  }

  export type FollowerUncheckedUpdateWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FollowerUncheckedUpdateManyWithoutCommunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ForoUpdateWithoutComunityInput = {
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUpdateOneWithoutForoNestedInput
    responses?: ResponseUpdateOneWithoutForoNestedInput
  }

  export type ForoUncheckedUpdateWithoutComunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    answers?: AnswerUncheckedUpdateOneWithoutForoNestedInput
    responses?: ResponseUncheckedUpdateOneWithoutForoNestedInput
  }

  export type ForoUncheckedUpdateManyWithoutComunityInput = {
    id?: IntFieldUpdateOperationsInput | number
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    date_publication?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    date_update?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ResponseCreateManyAnswerInput = {
    id?: number
    message?: string | null
    foroId: number
  }

  export type ResponseUpdateWithoutAnswerInput = {
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foro?: ForoUpdateOneRequiredWithoutResponsesNestedInput
  }

  export type ResponseUncheckedUpdateWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
  }

  export type ResponseUncheckedUpdateManyWithoutAnswerInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: NullableStringFieldUpdateOperationsInput | string | null
    foroId?: IntFieldUpdateOperationsInput | number
  }

  export type LinkCreateManyRolInput = {
    id?: number
    name: string
    Link: string
  }

  export type LinkUpdateWithoutRolInput = {
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
    userLineLink?: user_line_linkUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
    userLineLink?: user_line_linkUncheckedUpdateManyWithoutLinkNestedInput
  }

  export type LinkUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    Link?: StringFieldUpdateOperationsInput | string
  }

  export type user_line_linkCreateManyLinkInput = {
    id?: number
    userId: number
  }

  export type user_line_linkUpdateWithoutLinkInput = {
    user?: UserUpdateOneRequiredWithoutUser_line_linkNestedInput
  }

  export type user_line_linkUncheckedUpdateWithoutLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type user_line_linkUncheckedUpdateManyWithoutLinkInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyCategoryInput = {
    id?: number
    userId: number
    serviceid?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
  }

  export type ProductUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    service?: ServiceUpdateOneWithoutProductsNestedInput
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    serviceid?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type ProductCreateManyServiceInput = {
    id?: number
    userId: number
    categoryId?: number | null
    name: string
    description?: string | null
    price?: string | null
    date_create?: string | null
    status?: boolean | null
  }

  export type ProductUpdateWithoutServiceInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user?: UserUpdateOneRequiredWithoutProductsNestedInput
    category?: CategoryUpdateOneWithoutProductsNestedInput
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutServiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    date_create?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type Inv_Line_ProCreateManyProductInput = {
    id?: number
    invoiceId: number
  }

  export type Inv_Line_ProUpdateWithoutProductInput = {
    invoice?: InvoiceUpdateOneRequiredWithoutInv_line_prosNestedInput
  }

  export type Inv_Line_ProUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
  }

  export type Inv_Line_ProUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    invoiceId?: IntFieldUpdateOperationsInput | number
  }

  export type InvoiceCreateManyCustomerInput = {
    id?: number
    date: Date | string
  }

  export type PublicationCreateManyCustomerInput = {
    id?: number
    userId?: number | null
    name: string
    description?: string | null
    image?: Buffer | null
    date: Date | string
    status: boolean
  }

  export type InvoiceUpdateWithoutCustomerInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    inv_line_pros?: Inv_Line_ProUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    inv_line_pros?: Inv_Line_ProUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PublicationUpdateWithoutCustomerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutPublicationsNestedInput
    reactios?: ReactUpdateManyWithoutPublicationNestedInput
    comments?: CommentUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
    reactios?: ReactUncheckedUpdateManyWithoutPublicationNestedInput
    comments?: CommentUncheckedUpdateManyWithoutPublicationNestedInput
  }

  export type PublicationUncheckedUpdateManyWithoutCustomerInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableBytesFieldUpdateOperationsInput | Buffer | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: BoolFieldUpdateOperationsInput | boolean
  }

  export type Inv_Line_ProCreateManyInvoiceInput = {
    id?: number
    productId: number
  }

  export type Inv_Line_ProUpdateWithoutInvoiceInput = {
    product?: ProductUpdateOneRequiredWithoutInv_line_prosNestedInput
  }

  export type Inv_Line_ProUncheckedUpdateWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type Inv_Line_ProUncheckedUpdateManyWithoutInvoiceInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type ReactCreateManyPublicationInput = {
    id?: number
    name: string
  }

  export type CommentCreateManyPublicationInput = {
    id?: number
    text: string
  }

  export type ReactUpdateWithoutPublicationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReactUncheckedUpdateWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ReactUncheckedUpdateManyWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpdateWithoutPublicationInput = {
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUncheckedUpdateManyWithoutPublicationInput = {
    id?: IntFieldUpdateOperationsInput | number
    text?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComunityCountOutputTypeDefaultArgs instead
     */
    export type ComunityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComunityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnswerCountOutputTypeDefaultArgs instead
     */
    export type AnswerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnswerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolCountOutputTypeDefaultArgs instead
     */
    export type RolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LinkCountOutputTypeDefaultArgs instead
     */
    export type LinkCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LinkCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceCountOutputTypeDefaultArgs instead
     */
    export type ServiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationCountOutputTypeDefaultArgs instead
     */
    export type PublicationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FollowerDefaultArgs instead
     */
    export type FollowerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FollowerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComunityDefaultArgs instead
     */
    export type ComunityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComunityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForoDefaultArgs instead
     */
    export type ForoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnswerDefaultArgs instead
     */
    export type AnswerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnswerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ResponseDefaultArgs instead
     */
    export type ResponseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ResponseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RolDefaultArgs instead
     */
    export type RolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LinkDefaultArgs instead
     */
    export type LinkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LinkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use user_line_linkDefaultArgs instead
     */
    export type user_line_linkArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = user_line_linkDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ServiceDefaultArgs instead
     */
    export type ServiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ServiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Inv_Line_ProDefaultArgs instead
     */
    export type Inv_Line_ProArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Inv_Line_ProDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PublicationDefaultArgs instead
     */
    export type PublicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PublicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReactDefaultArgs instead
     */
    export type ReactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReactDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}